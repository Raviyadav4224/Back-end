1. What is Spring Data JPA ?

    * Spring Data JPA is a part of Spring Data project that simplifies working with Relational Databases
      using JPA

    * It is a High Level abstraction of JPA and Hibernate

    * It is built on the top of JPA and Hibernate and eliminates the need to write standard CRUD operation
      queries manually

    * It provides built in repository interfaces such as JpaRepository, CrudRepository etc which provides
      methods such as findById , save etc

    * It also generates queries based on method names like findByUsername etc and supports custom queries 
      using @Query

    * spring-boot-starter-jpa includes Hibernate as its default JPA provider , No need to manually manage 
      packages , it auto configures everything , just the starter jpa and Database driver is all you need

2. JPA vs Hibernate vs Spring Data JPA

    JPA contains set of interfaces that define how ORM should work

    Hibernate is an implementation of these interfaces i.e JPA

    Spring Data JPA is an abstraction of Hibernate and JPA and eliminates boiler plate code and allows 
    developers to focus more on business logic

3. JpaRepository, CrudRepository, PagingAndSortingRepository

    CrudRepository -

        Provides basic CRUD operations 
        like -
            S save(S entity);
            Optional<T> findById(ID id);
            Iterable<T> findAll();
            void deleteById(ID id);
            boolean existsById(ID id);

    PagingAndSortingRepository -

        Add supports for Sorting and Pagination and extends the CrudRepository

        example -
            public interface UserRepository extends PagingAndSortingRepository<User, Long> {
                List<User> findByUsernameContaining(String name, Pageable pageable);
            }

    JpaRepository -

        JPA extends both PagingAndSortingRepository and CrudRepository and adds JPA specific methods
        
        example -
            public interface UserRepository extends JpaRepository<User, Long> {
                List<User> findByUsernameContainingIgnoreCase(String keyword);
            }

4. @Transient - 

    @Transient in JPA is used when you want to keep a field in your entity class but don't want
    it to be mapped to any database column. It’s useful for computed values or fields used only in 
    application logic

    example -

        @Transient
        private double totalPrice;  // Not stored in DB

5. Pagination And Sorting -

    We can use Pageable and Sort classes to do the same
    example -

        Controller 
            public List<User> getAllUsers(
                    @RequestParam(defaultValue = "0") int page,
                    @RequestParam(defaultValue = "5") int size,
                    @RequestParam(defaultValue = "id") String sortBy,
                    @RequestParam(defaultValue = "asc") String direction
                    ) {
                return userService.getAllUsers(page,size,sortBy,direction);
            }
        
        Service -

            public List<User> getAllUsers(int page, int size, String sortBy, String direction) {
                Sort sort = direction.equalsIgnoreCase("asc") ? Sort.by(sortBy).ascending() : Sort.by(sortBy).descending();
                Pageable pageable = PageRequest.of(page, size, sort);
                return userRepo.findAll(pageable).get().collect(Collectors.toList());
            }

6. @CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy -

    @EnableJpaAuditing(auditorAwareRef = "auditorProvider")
        
    @Component
    public class AuditorAwareImpl implements AuditorAware<String> {
        @Override
        public Optional<String> getCurrentAuditor() {
            // You can fetch it from Spring Security context, or hardcode for testing
            return Optional.of("ravi"); // or SecurityContextHolder.getContext().getAuthentication().getName()
        }
    }

7. * @Transactional -  

    * It ensures that a series of database operation works as a single TestingUnit

    * If any one of the operations fails the entire transaction is rolled back to maintain data consistency

    * By default Transactional checks UNCHECKED EXCEPTIONS i.e RuntimeException and its subclasses

    * To rollback on checked exceptions use @Transactional( rollbackFor = Exception.class ) 

    * Internal method calls inside the same class won't apply @Transactional.
        example 
        class user.java
            @Transactional
            public void outer() {
                inner();  // @Transactional on inner() won't work here!
            }

            @Transactional
            public void inner() {
                throw new RuntimeException("Rollback?");
            }

8. @Query annotation (JPQL and native SQL) - 

    Query annotation lets you write custom queries using JPQL or Native SQL Queries

    JPQL - Based on Entity Class and fields
        @Query(value = "SELECT u FROM users u WHERE u.username = :username")

    Native SQL Query - Based on actual DB Table and Column Name
        @Query(value = "SELECT * FROM users WHERE username = :username", nativeQuery = true)

9. N+1 Problem - 

    List<User> users = userRepository.findAll();

    when we do userRepo.findAll()

    if user has OneToOne or OneToMany mapping

    1st - It fetches all the users
    2nd - For all the users it fetches its userprofile 

    So for say N users , first it runs once then for every user it runs once
    i.e Total: 1 (initial) + N (extra queries) = N+1 queries

    * Instead use FETCH JOIN which solves This
    
        @Query("SELECT u FROM User u JOIN FETCH u.userProfile") // ✅ single query
        List<User> findAllUsersWithProfile()

10. Scenario's where Transactional Applies -

    1. Spring marks a transaction for rollback when the exception is thrown and not caught within the
       same transaction boundary.

        Example - 

            1.   @Transactional
                public String transferMoney() {
                    try {
                        if (fromUser.getBalance() <= 0) {
                            throw new RuntimeException("Run time exceptoin");
                        }
                    } catch (Exception e) {
                        System.out.println("Handling runtime exception, and checking rollback happens or not");
                        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                    }
                
                ** Here Exception is handled, so spring transaction doesnot marks it for Rollback

            2.   @Transactional
                public String transferMoney() {
                        if (fromUser.getBalance() <= 0) {
                            throw new RuntimeException("Run time exceptoin");
                        }
                    }

                ** Here Exception is not handled, so spring transaction marks it for Rollback and when Exception 
                is thrown Rollback happens
    
    2. Internal method calls for the same class, Spring Transactional doesnot apply , since Spring’s 
       transaction management relies on proxy-based interception, which is bypassed in such cases.

        Example 
          class user.java
            @Transactional
            public void outer() {
                inner();  // @Transactional on inner() won't work here!
            }

            @Transactional(propagation = Propagation.REQUIRES_NEW)
            public void inner() {
                throw new RuntimeException("Rollback?");
            }
        
        ** Here inner will throw RuntimeException and Since same class method is called, Spring's proxy
           based mechanism won't create new Transaction and works within the same one
           Even if propagation = REQUIRES_NEW is used then also it wont work

    3. @Transactional(readOnly = true) is mainly used to:

        Ensure consistency across multiple reads.

        Improve performance by skipping dirty-checking and flushing.

        Potentially enable database-level optimizations for read-only workloads.

    | Scenario                                | Works / Doesn’t work   | Why?                             |
    | --------------------------------------- | --------------------   | -------------------------------- |
    | Public method, called from outside      | ✅ Works              | Proxy applies                    |
    | Private method                          | ❌ Doesn’t work       | Proxies don’t intercept          |
    | Self-invocation                         | ❌ Doesn’t work       | Bypasses proxy                   |
    | Class-level annotation                  | ✅ Works              | All public methods intercepted   |
    | Runtime exception                       | ✅ Rolls back         | Default behavior                 |
    | Checked exception without config        | ❌ Doesn’t roll back  | Not considered unless configured |
    | No transaction manager configured       | ❌ Doesn’t work       | Spring can't manage transaction  |
    | Final class/method                      | ❌ Doesn’t work       | Proxy can't wrap it              |
    | Non-Spring bean                         | ❌ Doesn’t work       | No proxy, no interception        |
    | Read-only queries                       | ✅ Works              | Optimized behavior               |
    | Using jakarta.transaction.Transactional | ❌ May not work       | Requires JTA or container config |
