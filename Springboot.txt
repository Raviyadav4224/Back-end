1. What is Spring Boot -

    Springboot is a framework which is built on the top of Spring that simplifies the developement of
    spring applications by

        * Eliminating the boiler plate configuration
        * It provides embedded servers like Tomcat, Jetty
        * Uses default configurations i.e auto-configuration
        * Supports rapid developement with production ready features

2. Spring Core vs Springboot -

    | Feature                   | **Spring Core**                                                                                          | **Spring Boot**                                                                                  |
    | ------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
    | **Definition**            | Base framework for building Java applications using DI and AOP         | Extension of Spring that makes it easier to build production-ready applications quickly          |
    | **Setup**                 | Manual configuration of beans, XML or Java-based                       | Auto-configuration based on classpath contents                                                   |
    | **Boilerplate Code**      | Requires a lot of boilerplate code (XML configs, bean declarations)    | Minimal boilerplate using starters and embedded server                                           |
    | **Web Server Setup**      | External servers like Tomcat, Jetty need to be manually deployed       | Comes with **embedded Tomcat/Jetty** â€“ just run the app like a Java program                      |
    | **Configuration Files**   | Often uses **XML files** or `@Configuration` in Java                   | Uses `application.properties` or `application.yml` for configuration                             |
    | **Dependencies**          | You need to add all required dependencies manually in `pom.xml`        | Uses **starter dependencies** (e.g., `spring-boot-starter-web`) which bundle common dependencies |
    | **Deployment**            | WAR file generation, deploy to external servlet container              | Runs as a **standalone JAR** (just run with `java -jar`)                                         |
    | **Application Bootstrap** | You create your own `main` method with lots of context loading         | Just annotate with `@SpringBootApplication` and run                                              |
    | **Dev Tools**             | No built-in dev support                                                | Comes with **Spring Boot DevTools** for live reload, hot swap, etc.                              |
    | **Monitoring**            | Needs manual integration for health checks/metrics                     | Has **Spring Boot Actuator** out of the box for health checks, metrics, etc.                     |
    | **Community/Modern Use**  | Still used for fine-grained control or in legacy projects              | Preferred in **modern enterprise apps** and microservices                                        |

3. Auto-Configuration in Springboot -

    It is one of the core features of Springboot application that allows developers to get started quickly
    by automatically configuring Spring application components based on classpath contents, defined beans 
    and application properties file

    * @SpringBootApplication -
        
        It is a combination of 

            @Configuration
            @ComponentScan
            @EnableAutoConfiguration

            | Annotation                 | Purpose                                                                                            |
            | -------------------------- | -------------------------------------------------------------------------------------------------- |
            | `@Configuration`           | Tells Spring that this class is a source of bean definitions                                       |
            | `@ComponentScan`           | Automatically scans the package and sub-packages for `@Component`, `@Service`, `@Repository`, etc. |
            | `@EnableAutoConfiguration` | Enables auto-configuration (scans `spring.factories`)                                              |

4. Springboot starter dependencies -

    It is a preconfigured dependency that simplifies the addition of commonly used libraries
    for example - spring-boot-starter-web Builds web,RESTful api's,spring-boot-starter-data-jpa etc

    * Custom starter dependency -

        1. Create a Maven spring project

        2. Add spring-boot-autoconfigure (To use Spring Boot AutoConfiguration) and add 
           spring-boot-starter (starter for transitive dependencies)

        3. Create LoggerClass and configure it w/o @SpringBootApplication
            package com.example.logger;

            public class LoggerService {
                public void log(String message) {
                    System.out.println("ðŸ”Š LoggerService: " + message);
                }
            }
            package com.example.logger;

            import org.springframework.context.annotation.Bean;
            import org.springframework.context.annotation.Configuration;

            @Configuration
            public class LoggerAutoConfig {

                @Bean
                public LoggerService loggerService() {
                    LoggerService logger = new LoggerService();
                    logger.log("LoggerService initialized via custom starter");
                    return logger;
                }
            }
        
        4. Located at: src/main/resources/META-INF/spring.factories

            org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
            com.example.logger.LoggerAutoConfig

            This is how Spring Boot discovers the config class when you import the starter

        5. Use the dependency in the POM of new project where you want to use this custom starter  

5. @RequestBody vs @PathVariable vs @RequestParam -

    RequestParam (user?id=10&name="ravi") - Refers to the Query parameters
    
    PathVariable (users/10) - Refers to the path variable of the URL

    RequestBody - JSON/ XML request body

6. JSON Validation in RequestBody -

    To validate the incoming JSON in request body we need to use 
    package - spring-boot-starter-validation

    example -
        public class UserDTO {
            @NotNull(message = "Name is required")
            @Size(min = 3)
            private String name;

            @Email(message = "Invalid email")
            private String email;
        }
    * @Valid is used to validate the field

    * It is applied at the CONTROLLER LEVEL

    * BindingResult interface gives result for any validation fail

    ** @Valid @RequestBody UserDto user,BindingResult result ( BindingResult must come after 
       @Valid else it will give error)

    *  example -
    
        public String registerUser(@PathVariable int id, @Valid @RequestBody UserDTO user, BindingResult result,
                @RequestParam String role) {
            System.out.println("User Requestbody" + user);
            if (result.hasErrors()) {
                System.out.println(
                        result.getAllErrors().stream().map(item -> item.getDefaultMessage()).collect(Collectors.toList()));
                return result.getAllErrors().stream().map(item -> item.getDefaultMessage()).collect(Collectors.toList())
                        .toString();
            }
            return usrservice.registerUser(id, user, role);
        }

7. How Springboot achieves Auto-Configuration -

    * Auto-configuration 
        
        * It is a feature in Spring Boot that automatically configures your application based on the 
          dependencies you include in your project. 

        * It aims to reduce or eliminate the need for boilerplate configuration by inspecting the classpath,
          properties, and environment, and setting up beans accordingly.

        * For example:

            If you add spring-boot-starter-data-jpa, it configures an EntityManager, DataSource, transaction 
            management, etc., without you having to explicitly define them.
    
    * Key Components Behind Auto-Configuration
        
        * Spring Factories and spring.factories File

            * Auto-configuration classes are registered using the META-INF/spring.factories file.

            * This file lists fully qualified class names under the key:

                org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
                org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
                org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration

            * When the application starts, Spring Boot loads these classes using the SpringFactoriesLoader.

        * @EnableAutoConfiguration Annotation

            * This is the main entry point that tells Spring Boot to load the auto-configuration classes.

            * Itâ€™s typically enabled via @SpringBootApplication, which is equivalent to:

                @SpringBootConfiguration
                @EnableAutoConfiguration
                @ComponentScan

            * @EnableAutoConfiguration uses @Import(AutoConfigurationImportSelector.class), which selects
              and imports the appropriate auto-configuration classes at runtime.

        * AutoConfigurationImportSelector

            * It reads the spring.factories file.

            * It determines which configuration classes to load based on conditions.

            * It imports them into the application context.

        * Conditional Annotations

            * Most auto-configurations are only applied if certain conditions are met, using annotations like:

                @ConditionalOnClass â€“ Applies configuration if a certain class is present.

                @ConditionalOnMissingBean â€“ Applies configuration if a specific bean is missing.

                @ConditionalOnProperty â€“ Applies configuration if a property is set in application.properties or application.yml.

                @ConditionalOnBean â€“ Applies only if a bean is already present.

            * For example, DataSourceAutoConfiguration is applied only if:

                DataSource class is present.

                No other DataSource bean is already configured.

                Properties like spring.datasource.url are defined.

        * Property Binding

            * Auto-configuration reads properties from application.properties or application.yml.

            * Uses @ConfigurationProperties to bind properties to Java objects.

            * Example: spring.datasource.url is bound to a DataSourceProperties bean.

        * How It All Works Together

            1. Spring Boot starts.

            2. @SpringBootApplication triggers @EnableAutoConfiguration.

            3. AutoConfigurationImportSelector reads spring.factories.

            4. It loads all auto-configuration classes.

            5. It checks conditions using @ConditionalOnClass, @ConditionalOnMissingBean, etc.

            6. It registers beans in the application context.

            7. Beans are available without explicit configuration.

        * Interview Ready Answer -
            
            Spring Boot achieves auto-configuration by using the @EnableAutoConfiguration annotation, which is included
            by default in @SpringBootApplication. This triggers the AutoConfigurationImportSelector to load 
            configuration classes listed in the META-INF/spring.factories file. These classes define how Spring Boot 
            should configure beans based on the dependencies available in the classpath and application properties.

            Auto-configuration classes use conditional annotations like @ConditionalOnClass, @ConditionalOnMissingBean, 
            and @ConditionalOnProperty to ensure that configurations are applied only when appropriate. It also reads 
            properties from application.properties or application.yml and binds them to Java beans using 
            @ConfigurationProperties. This way, Spring Boot can intelligently configure your application with 
            minimal explicit setup.

8. How do you EXCLUDE or OVERRIDE a specific auto-configuration class?

    * We can OVERRIDE the auto configuration class by providing our own bean of same type. So Springboot 
      version of Bean will not be used.

        * For example -

            @Configuration
            public class MyDataSourceConfig {

                @Bean
                public DataSource dataSource() {
                    HikariDataSource dataSource = new HikariDataSource();
                    dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
                    dataSource.setUsername("root");
                    dataSource.setPassword("password");
                    return dataSource;
                }
            }

        * Here SpringBoot will not auto configure the Datasource and your bean definition will take precedence
    
    * We can EXCLUDE AutoConfiguration class so that it doesnot apply at all    

        * @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})

        * @EnableAutoConfiguration(exclude = {HibernateJpaAutoConfiguration.class})

        * In Application.properties file 

            spring.autoconfigure.exclude=\
            org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
            org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration

9. How do you write a custom AutoConfiguration class?

    * Usecase - It is used for creating shared configurations like Logging, Cloud setup, authentication etc

    * We can create custom class like 

        @Configuration
        @ConditionalOnClass(CommonLogger.class)
        @ConditionalOnProperty(name = "common.logger.enabled", havingValue = "true", matchIfMissing = true)
        public class CommonLoggerAutoConfiguration {

            @Bean
            public CommonLogger commonLogger() {
                return new CommonLogger();
            }
        }
        
    * Create src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
      file and add the fully qualified class name 
      example - com.app.autoConfigure.CommonLoggerAutoConfiguration where this is a class which has Beans defined

    * Add spring-boot-autoconfigure package which tells spring that this is used to create custom auto
      config class
    
    * Build the project using mvn clean install, it builds and installs the jar in .m2 folder locally

    * Include the package in project where this package is to be used by including it in the dependency
       
       Example -

        <dependency>
			<groupId>com.ravi</groupId>
			<artifactId>SPRINBOOT_AUTO_CONFIG</artifactId>
			<version>0.0.1-SNAPSHOT</version>
		</dependency>


