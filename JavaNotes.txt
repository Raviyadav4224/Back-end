1. Polymorphism - 

    Poly means many and morphism means forms or behaviour

    Runtime Polymorphism - Method over-riding 
    Compile Time Polymorphism - Method overloading

2. Input from user - 

    * Using Scanner class -  

        Scanner sc = new Scanner(System.in);
        System.out.println("Enter something");
        String input = sc.next();

    * Using BufferedReader class - 

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter something");
        String input = reader.readLine();

        *BufferedReader class reads input in string format and requires further parsing

3. JDK vs JRE vs JIT vs JVM -

    JVM (Java Virtual Machine) - 
        It provides environment to execute java byte code i.e .class file
        
        JVM - Loads the bytecode
              Verifies and interprets the bytecode
              Executes the program

        * JVM is platform dependent, but the bytecode generated by the compiler is platform independent,
          thus making Java as platform independent
    
    JIT (Just in time compiler) - 

        JIT is a part of JVM which converts the frequently executed bytecode into native machine code at
        runtime to speed up execution
    
    JRE (Java Runtime Environment) - 

        JRE provides environment to run Java applications
        It includes -
            JVM for running bytecode
            Libraries - Essential Java Libraries like java.util , java.lang etc

    JDK (Java Development Kit) - 
        It is a software development kit used for developing java applications
        It includes - 
         JVM for running bytecode
         Libraries - Essential Java Libraries like java.util , java.lang etc
         Development tools Z( Compiler , Debugger)

    JVM - Executes bytecode
    JIT - part of JVM to optimize performance
    JRE - JVM + Libraries
    JDK - JRE + Development tools ( Compiler , Debugger)

4. Data Types - 

    Primitive data types - 
        Number - byte(1) , short(2), int(4), long(8)
        Float - float(4) , double(8)
        boolean - true or false (not 1 or 0)
        char - 2bytes (single quotation , UNICODES and not ASCII values)

    Non - Primitive data types - 
        Arrays
        String
        class
        Object
        Interface

5. Type Casting - 

    Implicit type casting - 

        Occurs automatically when converting a smaller value to a larger value 
        int a=10;
        double b=a;

    Explicit type casting - 
        Occurs when converting LARGER values to SMALLER values
        double b=100.0;
        int a=int(b);
    
    Upcasting - 
        Occurs between objects when casting a subclass object to superclass reference
        class Animal { (SuperClass)
            void sound() {
                System.out.println("Animal makes a sound");
            }
        }

        class Dog extends Animal { (SubClass)
            void sound() {
                System.out.println("Dog barks");
            }

            void specialAbility() {
                System.out.println("Dog can guard");
            }
        }
        public static vodi main(){
            Animal animal=new Dog();
            animal.sound(); // Upcasting

        }
        
    Downcasting - 
        Occurs when casting a superclass reference back to subclass 
            Dog dog=(Dog) animal;

6. Method Overloading - 

    When we create methods having same name but
        - different number of parameters
        - different type of parameters
        is termed as method overloading
    * It implements compile time polymorphism
    *return type doesnot matter

7. Strings - 

    Strings are immutable in Java
    Each time an operation is performed on string a new object is created

    String str1="Hello"
    String str2="World"
    str1.concat(str2);
    sysout(str1) ---> Hello
    String str=new String("This is a string")

    * Use equals() for string value comparison and == for reference comparison

8. String Pool - 
    String pool is a place in Heap Memory where all the strings defined are stored.
    Whenever we create a string variable , JVM checks the string pool and if string object is 
    present then same is returned else new object is created.

    * Strings created using the new keyword are created inside the HEAP memory and are UNIQUE 
      even if their contents mathces

        String str3=new String("Hello");
        String str4=new String("Hello");
        System.out.println(str4 == str3); // FALSE
    
9. Static Keyword -

    Static variables - 
        static String code;

        Static variable is a variable that is shared across all the instances of a class.
        It belongs to the class rather than any reference meaning only onecopy of variable
        exists in the memory
        * Static variables can be accessed directly using the ClassName, we dont need to create objects for
        them to access
        * JVM has special area to handle static variables

    Static methods - 

        Non static variables cannot be used inside static methods, because to use non static variables we need
        to create object of it.
        Indirect access is possible by sending a function parameters
        In Non Static methods static variable can be used.
    Static block - 

        static{
            name="Ravi"
        }

        Static block is used to initialize the static variables 
        If we initialize them in Constructor , Whenever object is created it static variable will be 
        re-initialized
        Whenever the Class loads static block is executed first and then Constructor method is called.
        Class loads only once
        * Class.forName("Person")  Loads the class

    *   Person p1=new Person()
        Here p1 is the reference variable of type Person
        new Person() creates an Object of type Person
        Person p1=new Person()
        The reference variable stores the reference of object created in Heap memory

10. Final keyword - 

    * Final keyword means CONSTANT
    * Value once declared final cannot be re-initialized
    * To stop method over-riding - declare method as final
    * To stop Inheritance - declare class as final
    * A Final object reference cannot be re-initialized but its internal state can still be modified
    
11. super() vs this() - 

    Every Constructor in Java has a method called super() which is used to call the parent's Constructor
    * First Parent's contructor gets called and then Child's contructor

    this() - Executes the Constructor of the same class

12. Inheritance -

        In Java MultiLevel Inheritance is supported but not Multiple Inheritance

        Inheritance is done using the keyword extends

        * For Multiple Inheritance - Multiple class can have same methods which creates an ambiguity i.e 
          JVM cannot decide which method to call, so Multiple inheritance is not supported

        * For Inheritance you only need .class file 

13. Object class -

        By default every class in Java extends the Object Class directly or indirectly
        It means every class in Java has access to the Object class methods
        * Primitive values doesn't extends the Object class

14. Wrapper class - 

        Primitive values doesn't extends the Object Class
        Wrapper class is a way to use Primitive data types as Objects
        Each data type has a corresponding Wrapper class

        For example -

            byte    -->	Byte	
            short   -->	Short	
            int     -->	Integer	
            long	--> Long	
            float	--> Float	
            double	--> Double	
            char	--> Character	
            boolean	--> Boolean

    * Advantage - Collections like ArrayList , HashMap etc requires Object class
    * Dis-Advantage - Once created, wrapper objects cannot be modified. Any change creates 
      a new object.

15. Anonymous inner class -
        abstract class Car {
            public abstract void Drive() ;
        }

        class Tata extends Car{

            public void Drive() {
                System.out.println("Tata is driving the Car");
            }
        }

        void main(){
            Car car=new Tata()
            car.Drive()
        }
        * Here the sole purpose of class Tata is to implement the abstract method
        * Same can be done using Lambda expression for Functional interface
            Car car=()-> System.out.println("Tata is driving the Car");
            This is known as Anonymous inner class i.e class without name

16. Abstract class -
        
        Abstract means just the idea and not its implementation
        * Abstract methods can only belong to Abstract class
        * When a class extends the Abstract class it must implement the abstract  methods
        * You cannot create an object of Abstract class only reference of that class can be created
        * Abstract class may or may not have abstract methods

17. Interface -

    * Instead of using abstract class we can use interface
    * Interface is not a Class
    * By default every method in an interface is PUBLIC and ABSTRACT
    * Interface will have only the methods and not their implementations
    * To implement an interface we use IMPLEMENTS keyword
    * All variables inside interface are FINAL and STATIC
    * Class can implement multiple interfaces but abstract class can extend only one class

        Class  -> Class (extends)
        Class  -> Interface  (implements)
        Interface -> Interface (extends)

    Functional Interface -
    
    Interface having only one method
    @FunctionalInteface annotation can be used
    Here Lambda expressions can be used

    Types of Interface - 
        Normal Interface -> Interface having MULTIPLE METHODS
        Functional Interface -> Interface having ONE METHOD
        Marker Interface -> Interface having NO METHODS (used in serialization)

    * We can create reference of an interface and object of a class
        example -
            Runnable obj=new A();

19. Lambda expression -

        It is applicable only for Functional interfaces i.e interface having only one method\

19. Exception Handling -
    
    Exceptions are events that can disrupt the normal execution of a program when some 
    unexpected situation occurs

    *Types of Exception -

        Checked exception - (COMPILE-TIME)

            These are exceptions that are checked at COMPILE TIME for example - SQLException, IOException etc

        Unchecked exception - (RUNTIME)

            These are exceptions that occur during the RUNTIME of a program, for example -Arithmetic Exception,
            NullPointerException etc 
    
    *finally block always gets executed but there are situations where it may not get executed -
        * If JVM crashes (due to OutOfMemoryError error)
        * try block has some infinite loop
        * If the thread executing the try block is killed

    *Custom Exception Handling -
        We can have custom exception handling by extending the Exception class
        for example - 
            Class CustomException extends Exception{
                CustomException(String message){
                    super(message)
                }
            }

            try {
                throw new CustomException("This is a custom exception");
            } catch (CustomException e) {
                System.out.println(e.getMessage());
            }
    *Throw - 
        It is used to explicitly throw an exception, for example - new CustomException("This is a custom exception");
    
    *Throws - 
        It is used to declare the exceptions that a METHOD can throw, it doesn't handles the exception itself
        for example -  void calculate(int x) throws ArithmeticException

    *Throwable -

        It is the root class in Java from which both Errors and Exceptions are derived

        Errors are mainly serious issues that the program should not try to handle (usually related to JVM)
        such as OutOfMemoryError error

        Error - OutOfMemoryError, StackOverflowError etc

        Exception - ArithmeticException, IOException etc

20. enum -
    enum are special data type that represents a group of constants
    It is used to define a set of named values
    *Enums are FINAL and STATIC implicitly
    *Enums are more than constants; they can include fields, constructors, and methods.
        for example -
            enum Day{
                MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
            }
            enum Season{
                    WINTER("Cold"),
                    SPRING("Warm"),
                    SUMMER("Hot"),
                    FALL("Cool");
                public String getDescription() {
                    return description;
                }

                private String description;
                // Constructor
                Day(String description) {
                    this.description = description;
                }
            }
            public static void main(String[] args) {
                Day today = Day.MONDAY;
                System.out.println("Today is: " + today);
                 for (Day d : Day.values()) {
                    System.out.println(d.getDescription());
                    }
            }

21. Collections class vs Collection interface -

    Collections -
        It is an utility class in Java that provides various static methods to work with Collection types
        (eg List, Set, Queue)
        for example - 
            Collections.sort()
            Collections.swap()
            Collections.reverse()
        * It doesn't implements the Collection interface although it is a part of Java Collections Framework
    
    Collection -
        It is an interface in Java Collections Framework
        It is implemented by List, Queue, Set interfaces
        * Classes that implements these interfaces ->
            List -> ArrayList, LinkedList, Vector
            Set -> HashSet, LinkedHashSet, TreeSet
            Queue -> PriorityQueue, LinkedList, ArrayDeque
    
    Map - 

        **Map is not the part of Collection interface, Although it is part of the Java Collections Framework 
        that represents a key-value pair where each key is UNIQUE

        * Map is an interface which is being implemented by classes such as HashMap, TreeMap, LinkedHashMap etc

        * HashMap stores is unordered format and allows 1 null key and multiple null values and for basic 
          operations such as get, put, it takes O(1) time

        * TreeMap stores in ordered format(ascending) and doesn't allows for null key values but allows multiple
          null values, for basic operations such as get, put it takes O(logN)

22. Comparator vs Comparable ->

    Comparator -
        It is an functional interface used to define CUSTOM SORTING order of objects without modifying the class
        It is a part of java.util package
        It is not the part of Java Collections Framework
        example Comparator<Student> marksComparator = (s1, s2) -> Integer.compare(s2.marks, s1.marks);

    Comparable -
        It is an functional interface which is used to define the NATURAL SORTING order of objects by 
        modifying the class
        It is implemented on Class level
        It is a part of java.lang
        for example -
            class Student implements Comparable<Student> {
                int id;
                String name;
                int marks;

                public Student(int id, String name, int marks) {
                    this.id = id;
                    this.name = name;
                    this.marks = marks;
                }

                @Override
                public int compareTo(Student other) {
                    return this.marks - other.marks; // Natural order: ascending marks
                }
            }

23. Threads ->
        Multiple tasks running at same time
        Smallest unit with which we can work is called a Thread
        * In  every Thread we need to have run method
        * Using start() method we start the Thread
            class A extends Thread{
                public void run() {
                    for (int i = 0; i < 10; i++) {
                        System.out.println("Hi");
                    }
                }
            }
            public static void main(String args[]) {
                A obj1 = new A();
                obj1.start();
            }
        * obj.getPriority() gives the priority of Thread , we can also set the priority of the Thread using
            obj.setPriority(10)
            
            0 --> Least priority
            0 --> Normal priority
            10 --> Highest priority

        * Thread is a class which implements Runnable interface
        * Ways to create a Thread - we can use Thread class or implement Runnable

24. Runnable ->

        We can create a Thread by implementing the Runnable interface
        But here we have to create a Thread object to have start() method
            Thread t1=new Thread(obj1);
            using Lambda expression -> 
                Runnable obj1 = ()->{
                    for (int i = 0; i < 10; i++) {
                        System.out.println("Hi");
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                };  
        * Thread safe means only one method can work with Thread at one time
        * join() method is used to wait for the Thread to finish
        * using SYNCHRONIZED both threads does not goes to the same variable at the same time, and prevents
            Race Condition
            public synchronized void increment() {
                this.count++;
            }
        *wait(), notify() methods -
    
25. Stream API ->

        Introduced in Java 8, it provides ways to process pipeline(series) of operations to the elements
        of a collection or other data source in a functional and declarative programming style
        It processes series of elements one at a time

        * stream() is used to create a stream and it provides various methods to be applied on the stream 
        such as map, filter, reduce
        for example -
            List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
            int product = numbers.stream().map(n->n*2);

        * collect() is used to terminate the stream and convert the stream back into specific data types

        * To handle infinite streams of data we can use any of the terminations operations like findfirst(),
            findAny(), anyMatch(), limit() etc
                for example - 
                    numbers.stream().limit(10).forEach(System.out::println);
                    Random random=new Random();
                    Stream.generate(random::nextInt).limit(5).forEach(System.out::println);
                    
26. String Builder vs StringBuffer -

        StringBuilder and StringBuffer are MUTABLE classes in java used for manipulating strings
        They provide methods to modify strings without creating new strings

        StringBuilder - 

            It is not synchronized so it is not safe in a multi-threaded environment
            It performs faster operations comapared to StringBuffer in single threaded environments

        StringBuffer -
            It is synchronized and Thread safe
            Slower due to synchronization
        
        example -
                StringBuilder sb = new StringBuilder(""); // Not Thread Safe since StringBuilder,use StringBuffer for thread safe
                Runnable task = () -> {
                    for (int i = 1; i < 50; i++) {
                        sb.append(i+" ");
                    }
                    System.out.println(sb);
                };

                Thread t1 = new Thread(task);
                Thread t2 = new Thread(task);

                t1.start();
                t2.start();

27. Generics - 

        Generics in Java provides a way to create Classes, Interfaces and methods with Type parameters.
        It allows you to write code with type safety
        It enhances code reusability since single classes, interfaces and methods can be used with different types
        ensuring compile time type safety

        * Basic syntax -
            class Box<T> {
                private T value;
                public T getValue() { return value;}
                public void setValue(T value) { this.value = value;}
            }
        * Generics can be used with Classes , Methods and interfaces
        * Method - 
                public static <T> void printArray(T[] array) {
                    for (T element : array) {
                        System.out.println(element);
                    }
                }
        * Bounding (Extending) a Class -
            Lower Bound -
                We can restrict the type that can be used with Generics
                class Box<T extends Number> - means Type T can be Number or its sub-classes

            Upper Bound -
                class Box<T super Number> - means any Type T can be super class of Number

        * WildCards (?)-

            WildCards are used for unknown types
                public static void printList(List<?> list) {
                    for (Object obj : list) {
                        System.out.println(obj);
                    }
                }
                (? extends T): Represents any type that is a subtype of T
                (? super T): Represents any type that is a supertype of T

        * Generic Interfaces -
            interface Pair<K, V> {
                K getKey();
                V getValue();
            }
        * Generics with Collection -
            List<Integers> num=new ArrayList<>();

    * Generics use TYPE ERASURE which means type information is removed during compile time.
      At runtime all Box<T> objects are treated as Box<Object>, Therefore we cannot instantiate Generics
      with primitive types

28. Date,Time & DateTime API - 

        Introduced in Java 8 in the java.time package.
        * All classes inside java.time are immutable and thread safe
        * It has TimeZones support

        classes - LocalDate, LocalTime, LocalDateTime, ZonedDateTime, DateTimeFormatter
        * LocalDate date = LocalDate.now();
        * DateTimeFormatter formatter= DateTimeFormatter.ofPattern("MM/dd/yyyy");
        * String currentDate=LocalDateTime.now().format(formatter);
        * LocalDate date=LocalDate.parse(birthday,formatter);

29. File Handling -

        It is a process that allows you to Read, Write, Update & Delete a file in Java

        Create -
        
            File file=new File("path with file name");
            if(file.createFile()) -- Creates file if not present 

        Read -  

            FileReader reader=new FileReader(above created file or filePath)

            reader.read() -- gives one charecter at a time and if no charecter are present then -1
            int text;
            while ((text = reader.read()) != -1) {
                System.out.print((char) text);
            }

        Write -

            FileWriter writer=new FileWriter(file);
            writer.write("This content is being written into the file");

        Update -
        
            FileWriter writer=new FileWriter(file,true(append true or false));
            writer.write("This content is appended");

        Delete -

            File file=new File("path with file name");
            if(file.delete()){
                file deleted successfully
            }

    * BufferedReader & BufferedWriter -

        BufferedWriter writer=new BufferedWriter(new FileWriter(file,true));
        BufferedReader reader = new BufferedReader(new FileReader(file));

    ** Every Read and Write operation directly interacts with HardDisk whereas,BufferedReader & BufferedWriter
       classes creates a buffer of chunk of data and reduces the number of interactions with HardDisk, Thus optimizing
       file handling process

30. Serialization, De-serialization ,transient & serialVersionUID-

        Serialization is the process of converting object's state into byte stream such that it can be 
        stored in a database or a file

        De-serialization is the reverse process where object is converted back into original state

        For Serialization (Writing into a File) -

            1. Opens file for writing into -
        
                FileOutputStream fos=new FileOutputStream("file path");

            2. Creates Buffer - 

                BufferedOutputStream bos=new BufferedOutputStream(fos);

            3. Converts Java objects into byte stream -

                ObjectOutputStream oos=new ObjectOutputStream(bos);

            4. Writes the object -
                oos.writeObject(Person)

        For De-Serialization -

            FileInputStream fis=new FileInputStream("path of file");
            BufferedInputStream bis=new BufferedInputStream(fis);
            ObjectInputStream ois=new ObjectInputStream(bis);
            ois.readObject();

        * Transient keyword is used to indicate that the field should not be serialized

        * SerialVersionUID - It is a unique identifier used during de-serialization process to verify 
            that the sender and receiver of serialized object have compatible classes
            It must be STATIC FINAL LONG
            private static final long serialVersionUID=1234L;

        * static and transient data members are not stored during serialization

        * Constructor of Object is not called during de-serialization of the object


31. Autoboxing -

    Autoboxing in Java is conversion of primitive data types into the corresponding Wrapper class Objects
    example -
        Integer a=new Integer();
        int num=10;
        a=num; // Here num is primitive which is being converted to Integer class object

        *Behind the scene Java uses Integer.valueOf(num) to convert into corresponding Wrapper class object
    
    * Caching in Wrapper classes - 

        By default Wrapper classes implements Cache in Java

        So when wrapper class creates caches it doesn't create new object for same values rather it refers 
        to the same value , but when the created object is out of range of cache it creates a new object    

        for example - 
            Integer a=100;
            Integer b=100;
             if(a==b)  // TRUE since in same range
            Integer a=200;
            Integer b=200;
             if(a==b)  // FALSE since out of range  
        
        * For Double and Float (No Caching is implemented) wrapper clasess always use .equals()

