1. OOPS - 

    * Polymorphism -

        Poly means many and morphism means forms or behaviour
        
        examples- 

            * Runtime Polymorphism - Method over-riding 
              Compile Time Polymorphism - Method overloading
            
            * A person behaves differently in Home as a Son and in office as a Engineer

    * Data Abstraction -

        Hiding the inner implementation and showing only the essential features is termed as Abstraction

        example -

            * In Java we use interfaces to implement data abstraction
            * Using Car, ATMs etc , not knowing how internally it works

    * Inheritance -

        Inheriting properties for parent to the child so that we can re-use the already created things

        example - Class extends another class

    * Data Encapsulation -

        Wrapping up of all the data members and methods as a single unit and restricting direct 
        access to some of the object components

        example - Medicine capsule

2. Input from user - 

    * Using Scanner class -  

        Scanner sc = new Scanner(System.in);
        System.out.println("Enter something");
        String input = sc.next();

    * Using BufferedReader class - 

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter something");
        String input = reader.readLine();

        *BufferedReader class reads input in string format and requires further parsing

3. JDK vs JRE vs JIT vs JVM -

    JVM (Java Virtual Machine) - 

        It provides environment to execute java byte code i.e .class file
        
        JVM - Loads the bytecode
              Verifies and interprets the bytecode
              Executes the program

        * JVM is platform dependent, but the bytecode generated by the compiler is platform independent,
          thus making Java as platform independent
    
    JIT (Just in time compiler) - 

        JIT is a part of JVM which converts the frequently executed bytecode into native machine code at
        runtime to speed up execution
    
    JRE (Java Runtime Environment) - 

        JRE provides environment to run Java applications
        It includes -
            JVM for running bytecode
            Libraries - Essential Java Libraries like java.util , java.lang etc

    JDK (Java Development Kit) - 

        It is a software development kit used for developing java applications
        It includes - 
         JVM for running bytecode
         Libraries - Essential Java Libraries like java.util , java.lang etc
         Development tools ( Compiler , Debugger)

    JVM - Executes bytecode
    JIT - part of JVM to optimize performance
    JRE - JVM + Libraries
    JDK - JRE + Libraries + Development tools ( Compiler , Debugger)

    * .java file is converted into bytecode (.class) by javac compiler which is platform independent, 
      then JVM loads the bytecode using the Class Loader, it interprets and uses JIT Compilation and shows
      output to the user

4. Data Types - 

    Primitive data types - 
    
        Number - byte(1) , short(2), int(4), long(8)
        Float - float(4) , double(8)
        boolean - true or false (not 1 or 0)
        char - 2bytes (single quotation , UNICODES and not ASCII values)

    Non - Primitive data types - 

        Arrays
        String
        class
        Object
        Interface

5. Type Casting - 

    Implicit type casting - 

        Occurs automatically when converting a smaller value to a larger value 
        int a=10;
        double b=a;

    Explicit type casting -

        Occurs when converting LARGER values to SMALLER values
        double b=100.0;
        int a=int(b);
    
    Upcasting - 

        Occurs between objects when casting a subclass object to superclass reference
        class Animal { (SuperClass)
            void sound() {
                System.out.println("Animal makes a sound");
            }
        }

        class Dog extends Animal { (SubClass)
            void sound() {
                System.out.println("Dog barks");
            }

            void specialAbility() {
                System.out.println("Dog can guard");
            }
        }
        public static void main(){
            Animal animal=new Dog();
            animal.sound(); // Upcasting

        }
        
    Downcasting - 

        Occurs when casting a superclass reference back to subclass 
            Dog dog=(Dog) animal;

6. Method Overloading vs Method Over-riding - 

    Method Overloading -
    
        When we create methods having same NAME but
            - DIFFERENT number of parameters
            - DIFFERENT type of parameters
            is termed as method overloading

        * It implements COMPILE time polymorphism

        * return type doesn't matter

        ** Overloaded methods can have different return types, but if only return type differs then its not
           overloading

    Method Over-riding -

        When we create method having 
            - SAME method name
            - SAME parameters
            - SAME return type
        
        * It implements RUNTIME Polymorphism where subclass provides the implementation of a method which
          is already defined in the Parent class. It helps to achieve dynamic behavior by allowing Child 
          class to change or extend the functionality of Parent class

    ** Can we OVERRIDE STATIC methods ? 

        We cannot override STATIC methods, since static methods are resolved at COMPILE time, they belong
        to the Class and not to the reference

    * Can an overriding method throw a different exception than the base method ?

        Yes, an overriding method can throw different exceptions then the base class only if it is
        NARROWER CHECKED EXCEPTION or FEWER. It cannot throw BROADER or UNCHECKED Exception since they 
        are not enforced at Compile time and will break the polymorphism
        
        example -
            class Parent {
                void doSomething() throws IOException {
                    System.out.println("Parent doing something");
                }
            }

            class Child extends Parent {
                // ❌ Hypothetically throwing a broader exception
                void doSomething() throws Exception {  
                    throw new Exception("Child exception");
                }
            }

            public class Main {
                public static void main(String[] args) {
                    Parent obj = new Child();
                    obj.doSomething(); // 
                }
            }

            The Problem:

                At compile time, the compiler only sees Parent obj = new Child();
                So it checks Parent.doSomething() — which throws only IOException
                But at runtime, it calls Child.doSomething() which throws Exception (a broader checked exception!)
                Now, the catch block doesn't handle Exception — leading to a runtime error

7. Strings vs String Pool - 

    * Strings are immutable in Java

    * Each time an operation is performed on string a new object is created

    * String pool is a place in Heap Memory where all the strings defined are stored.
      Whenever we create a string variable , JVM checks the string pool and if string object is 
      present then same is returned else new object is created.

        String str1 = "Hello"
        String str2 = "World"
        str1.concat(str2);
        sysout(str1) ---> Hello
        String str = new String("This is a string")
        
    * Strings created using the new keyword are created inside the HEAP memory and are UNIQUE 
      even if their contents mathces

        example - 

            String str1 = "Hello"
            String str2 = "Hello"
            System.out.println(str1 == str2); // TRUE Since refers to same value in pool

            String str3 = new String("Hello");
            String str4 = new String("Hello");
            System.out.println(str4 == str3); // FALSE Since creates new value everytime

    * Use equals() for string value comparison and == for reference comparison

8. Static Keyword -

    Static variables - 

        static String code;

        * Static variable is a variable that is shared across all the instances of a class.
        
        * It belongs to the class rather than any reference meaning only onecopy of variable
          exists in the memory

        * Static variables can be accessed directly using the ClassName, we dont need to create objects for
          them to access

        * JVM has special area to handle static variables i.e METHOD AREA

    Static methods - 

        * Non static variables cannot be used inside static methods, because to use non static variables we need
          to create object of it.

        * Indirect access is possible by sending a function parameters

        * In Non Static methods static variable can be used.

    Static block - 

        static {
            name="Ravi"
        }

        * Static block is used to initialize the static variables 

        * If we initialize them in Constructor , Whenever object is created, static variable will be 
          re-initialized

        * Whenever the Class loads static block is executed first and then Constructor method is called.

        * Class loads only once

        * Class.forName("Person") - Loads the class

        *   Person p1=new Person()
            Here p1 is the reference variable of type Person
            new Person() creates an Object of type Person
            Person p1=new Person()
            The reference variable stores the reference of object created in Heap memory

9. Final keyword - 

    * Final keyword means CONSTANT

    * Value once declared final cannot be re-initialized

    * To stop method over-riding - declare method as final i.e final methods cannot be over rided

    * To stop Inheritance - declare class as final i.e final class cannot be extended

    * A Final object reference cannot be re-initialized but its internal state can still be modified

        example -

            final Person p = new Person("Ravi");
            p.setName("Raj"); // ✅ Allowed – modifying internal state
            // p = new Person("Rahul"); ❌ Not allowed – reassigning final reference

    * How final variables are initialized ?

        * It depends on how they are created

            * If static, then during class load

                class App {
                    static final int VERSION;

                    static {
                        VERSION = 1;  // ✅ Static final initialized in static block
                    }
                }

            * If instance then during constructor call

                    class Car {
                        final String brand; // final instance variable

                        // Constructor – required if not initialized at declaration
                        Car(String brand) {
                            this.brand = brand;  // ✅ Valid initialization
                        }
                    }

            * If local then before accessing

                void doSomething() {
                    final int x; // declaration
                    x = 10;      // initialization before use ✅
                    System.out.println(x);
                }

10. super() vs this() - 

    Every Constructor in Java has a method called super() which is used to call the parent's Constructor
    * First Parent's contructor gets called and then Child's contructor

    this() - Executes the Constructor of the same class

11. Inheritance -

        * In Java MULTIPLE Inheritance is NOT supported
        
        * Inheritance is done using the keyword extends

        * For Multiple Inheritance - Multiple class can have same methods which creates an ambiguity i.e 
          JVM cannot decide which method to call, so Multiple inheritance is not supported

        * For Inheritance you only need .class file 

12. Object class -

        By default every class in Java extends the Object Class directly or indirectly
        It means every class in Java has access to the Object class methods
        * Primitive values doesn't extends the Object class

13. Wrapper class - 

        Primitive values doesn't extends the Object Class
        Wrapper class is a way to use Primitive data types as Objects
        Each data type has a corresponding Wrapper class

        For example -

            byte    -->	Byte	
            short   -->	Short	
            int     -->	Integer	
            long	--> Long	
            float	--> Float	
            double	--> Double	
            char	--> Character	
            boolean	--> Boolean

    * Advantage - Collections like ArrayList , HashMap etc requires Object class
    * Dis-Advantage - Once created, wrapper objects cannot be modified. Any change creates 
      a new object.

14. Anonymous inner class -

        abstract class Car {
            public abstract void Drive() ;
        }

        class Tata extends Car{

            public void Drive() {
                System.out.println("Tata is driving the Car");
            }
        }

        void main(){
            Car car=new Tata()
            car.Drive()
        }

        * Here the sole purpose of class Tata is to implement the abstract method

        * Same can be done using Lambda expression for Functional interface
            Car car=()-> System.out.println("Tata is driving the Car");
            This is known as Anonymous inner class i.e class without name

15. Abstract class -
        
        Abstract means just the idea and not its implementation

        * Abstract methods can only belong to Abstract class

        * When a class extends the Abstract class it must implement the abstract  methods

        * You cannot create an object of Abstract class only reference of that class can be created

        * Abstract class may or may not have abstract methods

16. Interface -

    * Instead of using abstract class we can use interface

    * Interface is not a Class

    * By default every method in an interface is PUBLIC and ABSTRACT

    * Interface will have only the methods and not their implementations

    * To implement an interface we use IMPLEMENTS keyword

    * All variables inside interface are FINAL and STATIC

    * Class can implement multiple interfaces but abstract class can extend only one class

        Class  -> Class (extends)
        Class  -> Interface  (implements)
        Interface -> Interface (extends)

    * Types of Interface -

        Normal Interface -> 
        
            Interface having MULTIPLE METHODS

        Functional Interface -> 
            
            Interface having only one method

            @FunctionalInteface annotation can be used

            It makes the code more readable, modular, allows using Lambda expressions and
            also used to avoid Anonymous inner class to create object

        Marker Interface -> 

            Interface having NO METHODS (used in serialization)
            
            Used to “mark” a class so that JVM gives special behavior

            Serializable → tells JVM this object can be serialized.

            Cloneable → tells JVM object can be cloned using clone().

    * examples -

        Vehicle class having startEngine as an abstract method
        Now twoWheeler class can define its own startEngine method annd similarly threeWheeler can also
        define its own startEngine method

    * We can create reference of an interface and object of a class
        example -
            Runnable obj=new A();

    ** STATIC methods in interface - 
        
        Static methods in interfaces acts as a utility helper methods

        We cannot OVERRIDE static methods in an interface since static methods are resolved at 
        compile time and override happens at run time using dynamic dispatch (polymorphism)

    ** DEFAULT methods in inteface -

        Before Java 8:
        If you added a new method to an existing interface, all implementing classes would break, 
        since they’d be forced to implement the new method.

        With Java 8+:
        You can provide a default implementation in the interface → existing classes don’t break.

        Default methods can be overridden

        If two interfaces provide the same default method, the implementing class must resolve the 
        conflict by overriding it.

17. Lambda expression -

        It is applicable only for Functional interfaces i.e interface having only one method

18. Exception Handling -
    
    Exceptions are events that can disrupt the normal execution of a program when some 
    unexpected situation occurs

    * Types of Exception -

        Checked exception - (COMPILE-TIME)

            These are exceptions that are checked at COMPILE TIME for example - SQLException, IOException etc

        Unchecked exception - (RUNTIME)

            These are exceptions that occur during the RUNTIME of a program, for example -Arithmetic Exception,
            NullPointerException etc 
    
    * finally block always gets executed but there are situations where it may not get executed -

        * If JVM crashes (due to OutOfMemoryError error)

        * try block has some infinite loop

        * If the thread executing the try block is killed

    * Custom Exception Handling -

        We can have custom exception handling by extending the Exception class
        for example - 
            Class CustomException extends Exception{
                CustomException(String message){
                    super(message)
                }
            }

            try {
                throw new CustomException("This is a custom exception");
            } catch (CustomException e) {
                System.out.println(e.getMessage());
            }

    * Throw - 

        It is used to explicitly throw an exception, for example - throw new CustomException("This is a custom exception");
    
    * Throws - 

        It is used to declare the exceptions that a METHOD can throw, it doesn't handles the exception itself
        for example -  void calculate(int x) throws ArithmeticException

    * Throwable -

        It is the root class in Java from which both Errors and Exceptions are derived

        Errors are mainly serious issues that the program should not try to handle (usually related to JVM)
        such as OutOfMemoryError error

        Error - OutOfMemoryError, StackOverflowError etc

        Exception - ArithmeticException, IOException etc

19. enum -

    enum are special data type that represents a group of constants

    It is used to define a set of named values

    * Enums are FINAL and STATIC implicitly

    * Enums are more than constants; they can include fields, constructors, and methods.
        for example -
            enum Day{
                MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
            }
            enum Season{
                    WINTER("Cold"),
                    SPRING("Warm"),
                    SUMMER("Hot"),
                    FALL("Cool");
                public String getDescription() {
                    return description;
                }

                private String description;
                // Constructor
                Day(String description) {
                    this.description = description;
                }
            }
            public static void main(String[] args) {
                Day today = Day.MONDAY;
                System.out.println("Today is: " + today);
                 for (Day d : Day.values()) {
                    System.out.println(d.getDescription());
                    }
            }

20. Collections class vs Collection interface -

    Collections -
    
        It is an utility class in Java that provides various static methods to work with Collection types
        (eg List, Set, Queue)

        for example - 

            Collections.sort()
            Collections.swap()
            Collections.reverse()
            Collections.max()
            Collections.min()
            Collections.replaceAll()
            Collections.frequency()

        * It doesn't implements the Collection interface although it is a part of Java Collections Framework
    
    Collection -

        It is an interface in Java Collections Framework

        It is implemented by List, Queue, Set interfaces

        * Classes that implements these interfaces ->

            List -> ArrayList, LinkedList, Vector

            Set -> HashSet, LinkedHashSet, TreeSet

            Queue -> PriorityQueue, LinkedList, ArrayDeque

        * ArrayList vs LinkedList vs Vector -

            ArrayList uses DYNAMIC ARRAY and is great for random access i.e get/set by index 
            takes O(1) time but slower for insert/remove in middle as it takes O(n) time and NOT
            thread safe

            Whereas LinkedList uses DOUBLY LINKED LIST and is great for frequent insertion/deletion O(1)
            but slow for random access O(n) and not thread safe

            Vector is similar to ArrayList but it is Thread safe but slower than ArrayList due to 
            synchronization
            
    Map - 

        **Map is not the part of Collection interface, Although it is part of the Java Collections Framework 
          that represents a key-value pair where each key is UNIQUE

        * Map is an interface which is being implemented by classes such as HashMap, TreeMap, LinkedHashMap etc

        * HashMap stores is unordered format and allows 1 null key and multiple null values and for basic 
          operations such as get, put, it takes O(1) time

        * TreeMap stores in ordered format(ascending) and doesn't allows for null key values but allows multiple
          null values, for basic operations such as get, put it takes O(logN)

        * HashMap vs LinkedHashMap vs ConcurrentHashMap vs TreeMap -

            HashMap -

                An UNORDERED, NON-THREAD-SAFE map that allows one null key and multiple null values and 
                for basic operations such as get, put, it takes O(1) time
            
            LinkedHashMap -

                An ORDERED version of HashMap that maintains insertion order of entries using a 
                doubly-linked list internally.
            
            ConcurrentHashMap -

                A THREAD-SAFE version of HashMap that allows concurrent read/write operations without 
                locking the entire map

            TreeMap -

                A sorted map based on Red-Black Tree, which keeps keys in natural order 
                (or custom comparator) and does not allow null keys.

21. Comparator vs Comparable ->

    Comparator -

        It is an functional interface used to define CUSTOM SORTING order of objects without modifying the class

        It is a part of java.util package

        It is not the part of Java Collections Framework

        example Comparator<Student> marksComparator = (s1, s2) -> Integer.compare(s2.marks, s1.marks);

    Comparable -
    
        It is an functional interface which is used to define the NATURAL SORTING order of objects by 
        modifying the class

        It is implemented on Class level
        
        It is a part of java.lang
        
        for example -
            class Student implements Comparable<Student> {
                int id;
                String name;
                int marks;

                public Student(int id, String name, int marks) {
                    this.id = id;
                    this.name = name;
                    this.marks = marks;
                }

                @Override
                public int compareTo(Student other) {
                    return this.marks - other.marks; // Natural order: ascending marks
                }
            }
        List<Student> students = Arrays.asList(
            new Student(3, "Ravi",91),
            new Student(1, "Amit",92),
            new Student(2, "Karan",99)
        );

        Collections.sort(students); // Uses compareTo
        students.forEach(System.out::println);

22. Threads ,Runnable vs Callable ,Deadlock ->

        * Threading is the ability of CPU to run different tasks parallelly on different CPU cores

        * Smallest unit with which we can work is called a Thread
        
        * We can create Thread using 

            1. Extending Thread Class ( which internally implements the Runnable inteface )
            2. Implementing Runnable Interface
        
        * start() vs run() -

            start() creates a NEW THREAD and internally calls run() method inside the new thread

            run() - directly runs in the CURRENT THREAD

        * join() -
        
            When you call t1.join() on a thread t1, the current thread (e.g., main thread) pauses and 
            waits for t1 to complete before continuing further.

        * Thread.sleep() -  

            Pauses the current execution and continues after the specified time
            It doesn't releases the lock on the Object
        
        * wait(), notify(), notifyAll()  -

            * These methods are used for inter-thread communication and they belong to the Object class, 
              not Thread.
            
            * Used inside a synchronized block.

            * wait() - Releases the lock on the object and makes the thread wait until some other thread 
              calls notify() or notifyAll() on the same object.

            * notify() - Wakes up one waiting thread (chosen arbitrarily by JVM) that is waiting on the 
              same object’s monitor.

            * notifyAll() - Wakes up all waiting threads on the same object.

            * wait() releases the lock, sleep() does not.

            * wait() requires synchronization, sleep() doesn’t.

        * What happens when you call wait()?

            The current thread must hold the monitor lock (i.e., must be inside a synchronized block
            or method).

            The thread enters the WAITING state.

            The thread releases the lock (so others can proceed).

            The thread stays paused until it is Woken up using notify() or notifyAll() from another thread.

            When resumed, it reacquires the lock before continuing.
        
        * Example of Runnable with wait() and notify() -

            class SharedResource {
                private int data;
                private boolean hasData = false;

                public synchronized void produce(int value) {
                    while (hasData) { // if data already present, wait
                        try { wait(); } catch (InterruptedException e) { }
                    }
                    data = value;
                    hasData = true;
                    System.out.println("Produced: " + value);
                    notify(); // wake up consumer
                }

                public synchronized void consume() {
                    while (!hasData) { // if no data, wait
                        try { wait(); } catch (InterruptedException e) { }
                    }
                    System.out.println("Consumed: " + data);
                    hasData = false;
                    notify(); // wake up producer
                }
            }

            public class WaitNotifyExample {
                public static void main(String[] args) {
                    SharedResource resource = new SharedResource();

                    Thread producer = new Thread(() -> {
                        for (int i = 1; i <= 5; i++) {
                            resource.produce(i);
                            try { Thread.sleep(500); } catch (InterruptedException e) { }
                        }
                    });

                    Thread consumer = new Thread(() -> {
                        for (int i = 1; i <= 5; i++) {
                            resource.consume();
                            try { Thread.sleep(1000); } catch (InterruptedException e) { }
                        }
                    });

                    producer.start();
                    consumer.start();
                }
            }
        
        * Runnable -

            * We can create a Thread by implementing the Runnable interface

            * But here we have to create a Thread object to have start() method
            
                Thread t1=new Thread(obj1);
                using Lambda expression -> 
                    Runnable obj1 = ()->{
                        for (int i = 0; i < 10; i++) {
                            System.out.println("Hi");
                            try {
                                Thread.sleep(10);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    };  
            
            * Thread safe means only one method can work with Thread at one time

            * using SYNCHRONIZED both threads does not goes to the same block/method at the same time, 
              and prevents Race Condition

                public synchronized void increment() {
                    this.count++;
                }

        * Runnable vs Callable -

            * Runnable limitations is that it cannot return a Result (void run()) and is more like 
              run and forget, it doesn't throws Checked exceptions as well

            * Whereas Callable<V> return result of type V and can throw Checked exceptions 

            * Callable is used with ExecutorService which creates Threads, which is not managed by 
              the developer and then the task created using callable is submitted to submit method which 
              return a future result which can be used to get result of callable 
            
            * Executors.newSingleThreadExecutor - creates a single thread 
              Executors.newCachedThreadPool - creates unlimited no of new threads 
              Executors.newFixedThreadPool(n) - Creates n no of Threads 
            
            * Here we dont use wait(), join(), notify() since we are not managing creation of Threads and 
              starting of them
                
            * Example -
            
              ExecutorService executor = Executors.newSingleThreadExecutor();

                Callable<String> task = () -> {
                    System.out.println("Running in: " + Thread.currentThread().getName());
                    return "Callable result";
                };

                Future<String> future = executor.submit(task);
                System.out.println("Result: " + future.get());

                executor.shutdown();

        * Example for using callable - Fetching user data from multiple services (DB, API, Cache) 
          in parallel, and then combining results.

        * Thread Life cycle -

            Java threads go through 6 states:

                NEW  - Thread created but not started

                RUNNABLE - Thread is ready to Run

                RUNNING - Thread is currently running

                BLOCKED - Waiting for a lock

                WAITING - Waiting indefinitely ( eg join, wait)

                TIMED_WAITING - Waiting with timeout ( eg sleep() )

                TERMINATED - Thread has finished

        * obj.getPriority() gives the priority of Thread , we can also set the priority of the Thread using
            obj.setPriority(10)
            
            0 --> Least priority
            5 --> Normal priority
            10 --> Highest priority

        * Deadlock -

            * Deadlock occurs when two or more threads wait forever for resources locked by each other.

            * Example -

                final Resource resource1 = new Resource("Resource1");
                final Resource resource2 = new Resource("Resource2");

                // Thread 1 tries to lock resource1 first, then resource2
                Thread t1 = new Thread(() -> {
                    synchronized (resource1) {
                        System.out.println("Thread 1 locked " + resource1.getName());

                        try { Thread.sleep(100); } catch (InterruptedException e) {}

                        synchronized (resource2) {
                            System.out.println("Thread 1 locked " + resource2.getName());
                        }
                    }
                });

                // Thread 2 tries to lock resource2 first, then resource1
                Thread t2 = new Thread(() -> {
                    synchronized (resource2) {
                        System.out.println("Thread 2 locked " + resource2.getName());

                        try { Thread.sleep(100); } catch (InterruptedException e) {}

                        synchronized (resource1) {
                            System.out.println("Thread 2 locked " + resource1.getName());
                        }
                    }
                });

                t1.start();
                t2.start();

                * Thread 1 locks resource1.
                * Thread 2 locks resource2.
                * Thread 1 now wants resource2, but it’s already locked by Thread 2 → so Thread 1 waits.
                * Thread 2 now wants resource1, but it’s already locked by Thread 1 → so Thread 2 waits.
                * Neither can proceed → Deadlock.

23. Stream API ->

        * Introduced in Java 8, it provides ways to process pipeline(series) of operations to the elements
          of a collection or other data source in a functional and declarative programming style

        * It processes series of elements one at a time

        * stream() is used to create a stream and it provides various methods to be applied on the stream 
          such as map, filter, reduce
        
        * Intermediate operations - (lazy, return a stream)
          Examples: map, filter, sorted, distinct, limit, skip, flatMap.

          Terminal operations - (consume the stream, return non-stream result)
          Examples: collect, reduce, forEach, count, findFirst, findAny, toArray.
          Once a terminal operation is called, the stream cannot be reused.
        
        * numbers.stream().map().toList() - Creates Im-mutable List

        * numbers.stream().map().collect(Collectors.toList()) - Creates Mutable List

        * Collectors.toMap(Key,Value,if duplicate then what)

        * Collectors.groupingBy((e)->e.getDept(),Collectors.toList()) expects a classifier function (how to group elements)
          and optionally a downstream collector (like Collectors.toList() or Collectors.toSet())

        * numbers.stream().flatMap()

        * Comparator.comparing(Employee::getSalary) - Compares using comparator

        * collect() is used to terminate the stream and convert the stream back into specific data types

        * .collect(Collectors.summingInt(Employee::getSalary));

        * To handle infinite streams of data we can use any of the terminations operations like findfirst(),
            findAny(), anyMatch(), limit() etc

                for example - 

                    numbers.stream().limit(10).forEach(System.out::println);
                    Random random=new Random();
                    Stream.generate(random::nextInt).limit(5).forEach(System.out::println);
                    
        * Group by - employees
                    .stream()
                    .collect(Collectors
                    .groupingBy(Employee::getDepartment, Collectors.maxBy(Comparator.comparing(Employee::getSalary))))

24. StringBuilder vs StringBuffer -

        StringBuilder and StringBuffer are MUTABLE classes in java used for manipulating strings
        They provide methods to modify strings WITHOUT CREATING new strings

        StringBuilder - 

            It is not synchronized so it is not safe in a multi-threaded environment
            It performs faster operations comapared to StringBuffer in single threaded environments

        StringBuffer -
        
            It is synchronized and Thread safe
            Slower due to synchronization
        
        example -
                StringBuilder sb = new StringBuilder(""); // Not Thread Safe since StringBuilder,use StringBuffer for thread safe
                Runnable task = () -> {
                    for (int i = 1; i < 50; i++) {
                        sb.append(i+" ");
                    }
                    System.out.println(sb);
                };

                Thread t1 = new Thread(task);
                Thread t2 = new Thread(task);

                t1.start();
                t2.start();

25. Generics - 

        * Generics in Java provides a way to create Classes, Interfaces and methods with Type parameters.

        * It allows you to write code with type safety

        * It enhances code reusability since single classes, interfaces and methods can be used with different types
          ensuring compile time type safety

        * Basic syntax -
            class Box<T> {
                private T value;
                public T getValue() { return value;}
                public void setValue(T value) { this.value = value;}
            }

        * Generics can be used with Classes , Methods and interfaces

            Method - 
                public static <T> void printArray(T[] array) {
                    for (T element : array) {
                        System.out.println(element);
                    }
                }

        * Bounding (Extending) a Class -

            Lower Bound -

                * We can restrict the type that can be used with Generics

                * class Box<T extends Number> - means Type T can be Number or its sub-classes

                ** extends is for upper bounds — usable in class and method declarations

            Upper Bound -
            
                * class Box<T super Number> - means any Type T can be super class of Number

                ** super is for lower bounds — only usable in wildcards (<?>)

        * WildCards (?)-

            WildCards are used for unknown types

                public static void printList(List<?> list) {
                    for (Object obj : list) {
                        System.out.println(obj);
                    }
                }
                (? extends T): Represents any type that is a subtype of T
                (? super T): Represents any type that is a supertype of T

            * ? extends T (upper bound) → read-only producer.

            * ? super T (lower bound) → write-only consumer.

        * Generic Interfaces -

            interface Pair<K, V> {
                K getKey();
                V getValue();
            }

        * Generics with Collection -

            List<Integers> num=new ArrayList<>();

    * Wildcards (super, extends) only allowed in method parameters, not in class type parameters.

    * Generics use TYPE ERASURE which means type information is removed during compile time.
      At runtime all Box<T> objects are treated as Box<Object>, Therefore we cannot instantiate Generics
      with primitive types

    * We cannot instantiate a generic object like this
    
        T obj = new T();  // ❌ NO — Not allowed
        Why not ? Because of Type Erasure in Java. During compilation, Java removes the generic type 
        info (T) and replaces it with Object or the bound. So the JVM doesn't know what T really 
        is at runtime.

26. Date,Time & DateTime API - 

        Introduced in Java 8 in the java.time package.
        * All classes inside java.time are IMMUTABLE and THREAD SAFE

        * It has TimeZones support

        classes - LocalDate, LocalTime, LocalDateTime, ZonedDateTime, DateTimeFormatter
        * LocalDate date = LocalDate.now();
        * DateTimeFormatter formatter= DateTimeFormatter.ofPattern("MM/dd/yyyy");
        * String currentDate=LocalDateTime.now().format(formatter);
        * LocalDate date=LocalDate.parse(birthday,formatter);

        ** UTC ( Co-ordinated Universal Time ) is global reference clock not tied to any country or 
           time zone .It is always written with a Z i.e Zulu time 

        ** ISO is just a format of writing time, it can include Date, Date+Time, Date+Time+Time zone offset 
           or UTC 

        * We generally store UTC in DB's and convert them back to ISO format with local date time when 
          showing to user
        
        ** It has Time zone support and doesn't requires manual handling of offsets
           Example -
            Instant utc = Instant.now();
            ZonedDateTime ist = utc.atZone(ZoneId.of("Asia/Kolkata"));
            ZonedDateTime nyc = utc.atZone(ZoneId.of("America/New_York"));

        * Example -

            Instant ist= Instant.now() - Gives LocalDateTime in UTC
            String localdatetime = LocalDateTime.ofInstant(Instant.now(),ZoneId.systemDefault()) -- Converts LocalDateTime into ISO
            .format(DateTimeFormatter.ofPattern("dd-MMM-yyyy hh:mm a"));

27. File Handling -

        * Paths, Path and Files are used to work with Files and Paths in java, available in java.nio.* package

        * Path — 
            
            Represents a file/directory path
        
            Path path = Paths.get("data/file.txt");  // relative path

        * Paths — 
            
            Factory class to create Path objects

            Think of it as: A helper class to get Path instances

        * Files -
            
            Performs operations on files/directories
            It allows you to Read, Write, Update & Delete a file in Java
            Path path = Paths.get("file.txt");

            Reading -

                String content = Files.readString(path);
                List<String> lines = Files.readAllLines(path);
                Stream<String> stream = Files.lines(path);

            Writing -

                Files.writeString(path, "Hello");
                Files.write(path, List.of("Line 1", "Line 2"));

            Checking -

                Files.exists(path);
                Files.isDirectory(path);

            Directory ops -

                Files.list(path);
                Files.createDirectories(path);

            File ops -

                Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);
                Files.move(oldPath, newPath);
                Files.deleteIfExists(path);

            Binary -

                byte[] data = Files.readAllBytes(path);
                Files.write(path, byteArray);

    * BufferedReader & BufferedWriter -

        BufferedReader -

            Path path = Paths.get("data/notes.txt");

            try (BufferedReader reader = Files.newBufferedReader(path)) {
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println(line);
                }
            }

        BufferedWriter - 
            
            Path path = Paths.get("data/output.txt");

            try (BufferedWriter writer = Files.newBufferedWriter(path)) {
                writer.write("Hello, world!\n");
                writer.write("Buffered writing with Files!");
            }

    ** Every Read and Write operation directly interacts with HardDisk whereas,BufferedReader & BufferedWriter
       classes creates a buffer of chunk of data and reduces the number of interactions with HardDisk, Thus optimizing
       file handling process

28. Serialization, De-serialization ,transient & serialVersionUID-

        Serialization is the process of converting object's state into byte stream such that it can be 
        stored in a database or a file

        De-serialization is the reverse process where object is converted back into original state

        For Serialization (Writing into a File) -

            1. Opens file using the path -

                OutputStream fileOut = Files.newOutputStream(filePath);

            2. Creates Buffer - 

                BufferedOutputStream bos=new BufferedOutputStream(fos);

            3. Converts Java objects into byte stream -

                ObjectOutputStream oos=new ObjectOutputStream(bos); 
                OR
                ObjectOutputStream oos=new ObjectOutputStream(fileOut); 

            4. Writes the object -
                oos.writeObject(Person)

        For De-Serialization -

            InputStream fileIn = Files.newInputStream(filePath);
            BufferedInputStream bis=new BufferedInputStream(fileIn);

            ObjectInputStream ois=new ObjectInputStream(bis);
            OR 
            ObjectInputStream ois=new ObjectInputStream(fileIn);
            
            ois.readObject();

        * Transient keyword is used to indicate that the field should not be serialized

        * SerialVersionUID - 

            * It is a unique identifier used during de-serialization process to verify 
              that the sender and receiver of serialized object have compatible classes

            * It must be STATIC FINAL LONG
              private static final long serialVersionUID=1234L;

        * STATIC and TRANSIENT data members are not stored during serialization

        * Constructor of Object is not called during de-serialization of the object

29. Autoboxing -

    Autoboxing in Java is conversion of primitive data types into the corresponding Wrapper class Objects
    example -
        Integer a=new Integer();
        int num=10;
        a=num; // Here num is primitive which is being converted to Integer class object

        * Behind the scene Java uses Integer.valueOf(num) to convert into corresponding Wrapper class object
    
    * Caching in Wrapper classes - 

        By default Wrapper classes implements Cache in Java

        So when wrapper class creates caches it doesn't create new object for same values rather it refers 
        to the same value , but when the created object is out of range of cache it creates a new object    

        for example - 
            Integer a=100;
            Integer b=100;
             if(a==b)  // TRUE since in same range
            Integer a=200;
            Integer b=200;
             if(a==b)  // FALSE since out of range  
        
        * For Double and Float - No Caching is implemented

        * For Byte , Short, Integer( 0 to 127 ), Long, Character, Boolean wrapper classes cache is implemented

        * Always use .equals() for comparison of two values

30. 0.1 * 2  == 0.2 ✅ vs 0.1 * 3 == 0.3 ❌ -

    ✅ 0.1 * 2 == 0.2

        0.1 is approximated in binary (slightly off, but close)

        Multiplying by 2 gives a result very close to 0.2

        And 0.2 is also approximate, but they match closely enough

        So: true

    ❌ 0.1 * 3 == 0.3 -

        0.1 * 3 = 0.30000000000000004 (in binary floating-point)

        0.3 = 0.299999999999999988897 (approx)

        These values are not exactly equal, hence: false

    ✅ Correct Way to Compare Floating-Point Values
    Always compare floating-point numbers with a tolerance (epsilon):

    double a = 0.1 * 3;
    double b = 0.3;
    System.out.println(Math.abs(a - b) < 0.0000001); // ✅ true

    ** Due to floating-point precision errors, some decimal values like 0.1, 0.2, 0.3 cannot be 
        represented exactly in binary. So direct comparison with == is unreliable. It's safer to compare 
        using a tolerance range

31. Java 8 Features -

    1. Lambda Expressions - 
        
        Introduced functional-style programming by allowing us to write annonymous functions  
        List<String> names = Arrays.asList("Ravi", "Amit", "Karan");
        names.forEach(name -> System.out.println(name));

    2. Functional Interfaces -

        Interfaces with only one abstract method, used primarily with lambda expressions.
        Common examples: Runnable, Comparator, and custom @FunctionalInterface.

    3. Stream API -
    
        Introduced to process collections in a declarative and functional way (like filtering, mapping, reducing).
    
    4. Default and Static Methods in Interfaces -

        Interfaces can now have default implementations using the default keyword and also static methods.
        example:
        interface MyInterface {
            default void show() { System.out.println("Default Method"); }
            static void display() { System.out.println("Static Method"); }
        }

    5. Optional Class -

        Helps avoid NullPointerException by wrapping a value that may or may not be present.

    6. Method References -

        Shorthand for calling methods using ClassName::methodName.
        Example:
        names.forEach(System.out::println);

32. Optional Class ( Optional<T> ) -

    * Optional classes are used to handle null values without throwing Null Pointer Exceptions and helps
      to reduce the boiler plate code of checking for null values
    
    * Optional<T> is a container object introduced in Java 8.

    * It may or may not contain a non-null value.

      Example -

        Employee emp = null;

            if (emp != null && emp.getName() != null) {
            	System.out.println(emp.getName().toLowerCase());
            }
            else {
            	System.out.println("Emp is null");
            }

            Optional<Employee> optionalEmp = Optional.ofNullable(emp);

            String email = optionalEmp.map(Employee::getName).map(String::toLowerCase).orElse("Email not found");
            System.out.println(email);

    Common Methods -

    of() - 

        Create Optional with non-null value 
        It is used when we know that the value cannot be NULL

    ofNullable() - 

        Create Optional with null-safe value
        It is used when we know that value can be NULL

    empty() - 

        Create an empty Optional

    isPresent() - 

        Check if value exists
        optionalEmp.map(Employee::getName).ifPresent(user -> {
			System.out.println(user);
		});

    get() - 

        Get value (⚠ risky without check)

    orElse() - 

        Return default if value absent

    orElseGet() - 

        Use supplier for fallback

    orElseThrow() - 

        Throw exception if empty

    ifPresent() - 

        Run code if value present

    map() - 

        Transform the value if present

    flatMap() - 

        Same as map but avoids nested Optional

    filter() - 

        Keep value only if it matches condition

    🔹 Production Use Case (API) -

        Spring Boot REST API to fetch user by ID:

        @GetMapping("/users/{id}")
        public ResponseEntity<?> getUserById(@PathVariable Long id) {
            return userRepository.findById(id)
                .map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.status(404).body("User not found"));
        }   

33. equals() vs == - 

    equals() -
    
        Use .equals() when you want to check if two objects are logically equal (same data).

    == -
        
        Use == when you want to check if two objects are the exact same instance (reference).

    ** Always override .hashCode() when you override .equals() — it ensures correct behavior in 
       hash-based collections like HashSet or HashMap. 

    ** If two objects are equal according to .equals(), they must return the same hashCode(). 
       This ensures consistent behavior in hash-based collections like HashMap or HashSet. 
       However, the reverse isn't true — two different objects can have the same hashCode due to collisions

    examples - 

        Student s1 = new Student(1, "Ravi");
        Student s2 = new Student(1, "Ravi");

        s1 == s2;           // ❌ false — different memory references
        s1.equals(s2);      // ✅ true — same content (if equals is overridden)
        s1.equals(s2);      // ❌ false — same content (if equals is NOT overridden)

34. Performance & Optimization

     How do you detect and fix memory leaks in Java applications?

35. What’s your go-to approach for optimizing Java code for performance?

    Minimize unnecessary object creation (especially in loops)

    Prefer StringBuilder for string concatenation inside loops

    Use appropriate data structures (HashMap vs TreeMap)

    Leverage Java 8+ Streams carefully to avoid performance pitfalls

    Cache expensive operations (memoization, where applicable)

36. Which recent Java feature has had the most impact:

    Switch expressions improved readability and reduced boilerplate, especially in state machine or 
    command-based logic

        String result = switch (status) {
        case "ACTIVE" -> "User is active";
        case "BLOCKED" -> "User is blocked";
        case "Active": {
			yield "User is active";
		}
        default        -> "Unknown status";
        };

    * Instead of break statements, which simply exit the switch block, YIELD explicitly specifies 
        the value that the switch expression should evaluate to for a given case

37. Java Concepts & Best Practices ,What are some Java best practices you wish you had known earlier in your career?

    Early in my career, I wish I had known the importance of:

        Immutable objects: They're thread-safe by design and easier to reason about.

        Using Optional wisely instead of nulls to avoid NPEs.

        Writing unit tests first (TDD) — saves a lot of debugging time.

        Understanding the cost of using collections (e.g., ArrayList vs LinkedList performance differences).

38. How do you structure large-scale Java applications to keep them maintainable?

39. Fail-fast vs Fail-safe iterators -

    Fail-fast iterators -

        * Fail-fast is found in most of the Java collection Framework like ArrayList, HashMap,HashSet.

        * If we try to modify a collection while iterating through it, it throws ConcurrentModificationException
          i.e iterators work on Original collections and they check for structural modification(i.e add/remove)
          by comparing a modCount.
        
        * Fail-fast ensures that bugs like Multiple threads modifying the collection unexpectedly are
          detected earlier.

        * Example -

            List<String> fruits = new ArrayList<>();
            fruits.add("Apple");
            fruits.add("Banana");
            fruits.add("Orange");
            fruits.add("Grape");

            System.out.println("Original list: " + fruits);

            // Attempting to modify the list while iterating using an enhanced for loop
            for (String fruit : fruits) {
                if (fruit.equals("Banana")) {
                    fruits.remove(fruit); // This line will cause the exception
                }
            }

        * Fail-fast behavior applies only when using an iterator (directly or via for-each loop)
          Iterator + remove() → safe
          Iterator + list.remove() → unsafe

        * Adding/removing keys while iterating → Causes ConcurrentModificationException.

    Fail-safe iterators -

        * These are found in concurrent collections like ConcurrentHashMap

        * These iterators do not throw exception if collection is being modified during iteration
          since they iterate over a cloned snapshot of collection
        
        * Fail-safe is better for multi-threaded applications (safety).

40. Garbage Collection and Memory Leakage -

    Garbage Collection -

        * Java uses automatic garbage collection to free memory occupied by objects which are no longer
          reachable in the program.

        * Garbage collection is not deterministic i.e we cannot force garbage collection but only suggest
          using System.gc(), but JVM decides when to run it.
        
        * It works in three phases i.e Mark - Sweep - Compact 

          Mark - mark objects which are still reachable
          Sweep - Delete objects which are no longer reachable and reclaims memory
          Compact - Reorganize the memory

    Memory Leakages -

        * Memory leakage occurs when objects which are no longer needed but are still referenced and 
          Garbage collector cannot reclaim the memory. Over time this causes OutOfMemoryError.
        
        * Static fields holding objects -

            class MemoryLeak {
                private static List<String> cache = new ArrayList<>();
                public void addData(String data) {
                    cache.add(data); // static list keeps growing, never released
                }
            }
        * Unclosed resources 
        
        * To prevent memory leak we can use, try with resources which closes the resources , weak references,
          avoid unnecessary static references, some profiling tools to detect leaks.

41. Refletion in Java -
 
    * Reflection in Java is a feature which allows you to inspect and manipulate classes, methods, fields 
      and constructors at runtime even if you dont know them at compile time.

    * Normal Objects -  We use them when we know the Class Structure
      Reflection Objects - we use them when we dont know the Class Structure

    * Why Reflection is important -

        * Frameworks like Spring / Springboot uses Reflection behind the annotations like @Autowired, 
          @Entity, @RequestMapping etc
        
        * How Spring Boot Uses It -

            At startup, Spring scans classes and builds beans.

            For @Autowired private UserService userService;, Spring uses reflection:

            Field f = UserController.class.getDeclaredField("userService");
            f.setAccessible(true); // set private fields accessible
            f.set(controllerObj, userServiceBean);

            So beans are injected without new keyword, even into private fields

    * Example
        Employee emp = new Employee();
        emp.work();   // Output: Default Name is working...

        // --- Reflection Part ---
        // 1. Get Class reference
        Class<?> clazz = emp.getClass();

        // 2. Get private field "name"
        Field field = clazz.getDeclaredField("name");

        // 3. Allow access to private field
        field.setAccessible(true);

        // 4. Set new value into the private field
        field.set(emp, "Ravi Kumar");

        // 5. Verify change
        emp.work();   // Output: Ravi Kumar is working...

42. Internal working of HashMap -

    Imagine HashMap as a Locker Room

    1. The Locker Room (Array of Buckets)

        Think of a locker room with 16 lockers (default capacity).
        Each locker = bucket.

    2. The Key (hashCode)

        When you store something, you give the guard your key (hashCode).
        The guard runs it through a formula to decide which locker to put it in.

    3. Collision (Two keys for same locker)

        Sometimes, two people are told to use the same locker.

        Before Java 8: They kept their things in a linked list inside the locker.

        After Java 8: If the locker got too crowded (>8), the items were organized into a tree 
        (Red-Black tree) so searching is faster.

    4. Get (Search)

        When you come back, you hand your key.
        The guard knows which locker to open, and inside he checks equals() to find your exact item.

    5. Resize (Room Expansion)

        If the locker room gets 75% full, they build a bigger room (double the lockers).
        Then they re-distribute everything into new lockers → rehashing.

    6. Time Taken

        Normally, the guard directly takes you to your locker → O(1).

        If crowded (all in same locker):

        Before Java 8: Check one by one → O(n).

        After Java 8: Tree search → O(log n).

    Simple Summary for Interview

        HashMap = locker room (array of buckets).

        Put: Compute hash → find locker → place item.

        Get: Compute hash → open locker → search item.

        Collisions → list (old) or tree (new).

        Resize → bigger locker room at 75% full.