1. Polymorphism - 

    Poly means many and morphism means forms or behaviour

    Runtime Polymorphism - Method over-riding 
    Compile Time Polymorphism - Method overloading

2. Input from user - 

    * Using Scanner class -  

        Scanner sc = new Scanner(System.in);
        System.out.println("Enter something");
        String input = sc.next();

    * Using BufferedReader class - 

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter something");
        String input = reader.readLine();

        *BufferedReader class reads input in string format and requires further parsing

3. JDK vs JRE vs JIT vs JVM -

    JVM (Java Virtual Machine) - 
        It provides environment to execute java byte code i.e .class file
        
        JVM - Loads the bytecode
              Verifies and interprets the bytecode
              Executes the program

        * JVM is platform dependent, but the bytecode generated by the compiler is platform independent,
          thus making Java as platform independent
    
    JIT (Just in time compiler) - 

        JIT is a part of JVM which converts the frequently executed bytecode into native machine code at
        runtime to speed up execution
    
    JRE (Java Runtime Environment) - 

        JRE provides environment to run Java applications
        It includes -
            JVM for running bytecode
            Libraries - Essential Java Libraries like java.util , java.lang etc

    JDK (Java Development Kit) - 
        It is a software development kit used for developing java applications
        It includes - 
         JVM for running bytecode
         Libraries - Essential Java Libraries like java.util , java.lang etc
         Development tools Z( Compiler , Debugger)

    JVM - Executes bytecode
    JIT - part of JVM to optimize performance
    JRE - JVM + Libraries
    JDK - JRE + Development tools ( Compiler , Debugger)

4. Data Types - 

    Primitive data types - 
        Number - byte(1) , short(2), int(4), long(8)
        Float - float(4) , double(8)
        boolean - true or false (not 1 or 0)
        char - 2bytes (single quotation , UNICODES and not ASCII values)

    Non - Primitive data types - 
        Arrays
        String
        class
        Object
        Interface

5. Type Casting - 

    Implicit type casting - 

        Occurs automatically when converting a smaller value to a larger value 
        int a=10;
        double b=a;

    Explicit type casting - 
        Occurs when converting LARGER values to SMALLER values
        double b=100.0;
        int a=int(b);
    
    Upcasting - 
        Occurs between objects when casting a subclass object to superclass reference
        class Animal { (SuperClass)
            void sound() {
                System.out.println("Animal makes a sound");
            }
        }

        class Dog extends Animal { (SubClass)
            void sound() {
                System.out.println("Dog barks");
            }

            void specialAbility() {
                System.out.println("Dog can guard");
            }
        }
        public static vodi main(){
            Animal animal=new Dog();
            animal.sound(); // Upcasting

        }
        
    Downcasting - 
        Occurs when casting a superclass reference back to subclass 
            Dog dog=(Dog) animal;

6. Method Overloading - 

    When we create methods having same name but
        - different number of parameters
        - different type of parameters
        is termed as method overloading
    * It implements compile time polymorphism
    *return type doesnot matter

7. Strings - 

    Strings are immutable in Java
    Each time an operation is performed on string a new object is created

    String str1="Hello"
    String str2="World"
    str1.concat(str2);
    sysout(str1) ---> Hello
    String str=new String("This is a string")

    * Use equals() for string value comparison and == for reference comparison

8. String Pool - 
    String pool is a place in Heap Memory where all the strings defined are stored.
    Whenever we create a string variable , JVM checks the string pool and if string object is 
    present then same is returned else new object is created.

    * Strings created using the new keyword are created inside the HEAP memory and are UNIQUE 
      even if their contents mathces

        String str3=new String("Hello");
        String str4=new String("Hello");
        System.out.println(str4 == str3); // FALSE
    
9. Static Keyword -

    Static variables - 
        static String code;

        Static variable is a variable that is shared across all the instances of a class.
        It belongs to the class rather than any reference meaning only onecopy of variable
        exists in the memory
        * Static variables can be accessed directly using the ClassName, we dont need to create objects for
        them to access
        * JVM has special area to handle static variables

    Static methods - 

        Non static variables cannot be used inside static methods, because to use non static variables we need
        to create object of it.
        Indirect access is possible by sending a function parameters
        In Non Static methods static variable can be used.
    Static block - 

        static{
            name="Ravi"
        }

        Static block is used to initialize the static variables 
        If we initialize them in Constructor , Whenever object is created it static variable will be 
        re-initialized
        Whenever the Class loads static block is executed first and then Constructor method is called.
        Class loads only once
        * Class.forName("Person")  Loads the class

    *   Person p1=new Person()
        Here p1 is the reference variable of type Person
        new Person() creates an Object of type Person
        Person p1=new Person()
        The reference variable stores the reference of object created in Heap memory

10. Final keyword - 

    * Final keyword means CONSTANT
    * Value once declared final cannot be re-initialized
    * To stop method over-riding - declare method as final
    * To stop Inheritance - declare class as final
    * A Final object reference cannot be re-initialized but its internal state can still be modified
    
11. super() vs this() - 

    Every Constructor in Java has a method called super() which is used to call the parent's Constructor
    * First Parent's contructor gets called and then Child's contructor

    this() - Executes the Constructor of the same class

12. Inheritance -

        In Java MultiLevel Inheritance is supported but not Multiple Inheritance

        Inheritance is done using the keyword extends

        * For Multiple Inheritance - Multiple class can have same methods which creates an ambiguity i.e 
          JVM cannot decide which method to call, so Multiple inheritance is not supported

        * For Inheritance you only need .class file 

13. Object class -

        By default every class in Java extends the Object Class directly or indirectly
        It means every class in Java has access to the Object class methods
        * Primitive values doesn't extends the Object class

14. Wrapper class - 

        Primitive values doesn't extends the Object Class
        Wrapper class is a way to use Primitive data types as Objects
        Each data type has a corresponding Wrapper class

        For example -

            byte    -->	Byte	
            short   -->	Short	
            int     -->	Integer	
            long	--> Long	
            float	--> Float	
            double	--> Double	
            char	--> Character	
            boolean	--> Boolean

    * Advantage - Collections like ArrayList , HashMap etc requires Object class
    * Dis-Advantage - Once created, wrapper objects cannot be modified. Any change creates 
      a new object.

15. Anonymous inner class -
        abstract class Car {
            public abstract void Drive() ;
        }

        class Tata extends Car{

            public void Drive() {
                System.out.println("Tata is driving the Car");
            }
        }

        void main(){
            Car car=new Tata()
            car.Drive()
        }
        * Here the sole purpose of class Tata is to implement the abstract method
        * Same can be done using Lambda expression for Functional interface
            Car car=()-> System.out.println("Tata is driving the Car");
            This is known as Anonymous inner class i.e class without name

16. Abstract class -
        
        Abstract means just the idea and not its implementation
        * Abstract methods can only belong to Abstract class
        * When a class extends the Abstract class it must implement the abstract  methods
        * You cannot create an object of Abstract class on ly reference of that class can be created
        * Abstract class may or may not have abstract methods

17. Interface -

    * Instead of using abstract class we can use interface
    * Interface is not a Class
    * By default every method in an interface is PUBLIC and Abstract
    * Interface will have only the methods and not their implementations
    * To implement an interface we use IMPLEMENTS keyword
    * All variables inside interface are FINAL and STATIC
    * Class can implement multiple interfaces but abstract class can extend only one class

        Class  -> Class (extends)
        Class  -> Interface  (implements)
        Interface -> Interface (extends)

    Functional Interface -
    
    Interface having only one method
    @FunctionalInteface annotation can be used
    Here Lambda expressions can be used

    Types of Interface - 
        Normal Interface -> Interface having MULTIPLE METHODS
        Functional Interface -> Interface having ONE METHOD
        Marker Interface -> Interface having NO METHODS (used in serialization)

19. Lambda expression
19. Exception Handling
    Checked vs Unchecked exception
    Types of Exception
    try-catch
    try with multiple catch
    try catch finally
    condition where finally is not executed
    Custom Exception Handling
    Throw vs throws vs Throwable

20. Enum -
21. Threads
22. Collections vs Collection
23. Stream API
