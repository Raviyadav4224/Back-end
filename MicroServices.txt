1. What are Micro-Services -

    * Microservices are a way of designing an application as a collection of small, independent services 
      that each handle one specific task or feature

    * These services work together to build the complete system, but each one can be developed, deployed, 
      and maintained separately.

    * This makes the system easier to manage, scale, and update without affecting the entire application.

2. How it is implemented using Springboot -

    1. You set up Eureka Server, which acts as the discovery server.

    2. Each microservice acts as a Eureka Client, registers itself with Eureka Server at startup.

    3. When one microservice wants to communicate with another, it uses Feign Client.

        Feign automatically looks up the service from Eureka using the name specified.

        It builds the request to the correct instance without you needing to specify its IP or port.

3. Key Components of Microservices - 

    1. Service Discovery - Helps Microservices to find each other ( example using Eureka Server )
    2. API Gateway - Entry point for all Client Requests ( example Spring Cloud Gateway )
    3. Configuration Server - Central point to manage all Configuration ( example Spring Cloud config)
    4. Inter Service Communication - Services talk using RestTemplate  ( example using Feign Client )
    5. Load Balancing - Evenly distributes the Requests
    6. Resillence - Circuit Breakers, retires and timeout
    8. Security - JWTs and centralized authentication
    7. Monitoring - Health Check using Actuator  
    9. Logging - centralized log management

4. Interaction between one microservice and another microservice -

    | Type         | Example                    | Description                                             |
    | ------------ | -------------------------- | ------------------------------------------------------- |
    | Synchronous  | Feign Client, RestTemplate | Real-time communication; waits for a response.          |
    | Asynchronous | Kafka, RabbitMQ            | Decoupled communication; doesnâ€™t wait. Used for events. |

    * Communication using RestTemplate -

        private RestTemplate restTemp= new RestTemplate();
        restTemp.getForObject("http://localhost:8082/inventory?id=" + id, String.class)
        
5. API Gateway -

    * API Gateway acts as a single entry point for all client requests in a microservices architecture.
      Handles routing, authentication, rate limiting, logging, and load balancing.

    * In Spring ecosystem, we use Spring Cloud Gateway 

    * Spring Cloud Gateway comes in two flavors based on the underlying web stack:

      Reactive Gateway (WebFlux-based)
      Non-Reactive Gateway (WebMVC / Servlet-based)
    
    * Reactive vs Non-Reactive Gateway -
      
      | Feature              | **Reactive Gateway (WebFlux)**       | **Non-Reactive Gateway (WebMVC / Servlet)** |
      | -------------------- | ------------------------------------ | ------------------------------------------- |
      | Underlying stack     | Spring **WebFlux**                   | Spring **WebMVC**                           |
      | Programming model    | Reactive (Mono / Flux)               | Imperative / Blocking                       |
      | I/O model            | **Non-blocking**                     | **Blocking**                                |
      | Web server           | **Netty** (event-loop based)         | **Tomcat / Jetty / Undertow**               |
      | Thread model         | Few threads handle many requests     | One thread per request                      |
      | Concurrency handling | Very high (thousands of connections) | Limited by thread pool                      |
      | Resource usage       | Low memory, efficient CPU            | Higher memory under load                    |
      | Gateway filters      | `GlobalFilter` (Reactive)            | Servlet filters (`OncePerRequestFilter`)    |
      | Security filters     | Reactive Security filters            | Servlet Security filters                    |
      | Best suited for      | API Gateway, edge layer, streaming   | Simple / internal gateways                  |
      | Typical traffic      | High throughput, I/O heavy           | Moderate traffic                            |
      | Common architecture  | Gateway = Reactive, Services = MVC   | Entire stack MVC                            |
      | Example use case     | Netflix-style edge gateway           | Internal company gateway                    |

    * Nginx vs Spring Cloud Gateway -
      
      Nginx is an Infrastructure aware gateway and optimized for traffic control and protection 
      It acts as a Load balancer and reverse Proxy

      Whereas Spring cloud gateway is an application/service aware gateway best at handling application level
      logics

    * To Create Reactive Spring Cloud Gateway -

      * packages required - Reactive spring cloud gateway, spring security(For handling security), Oauth2-resolver
        (for handling JWT's)
    
6. Major concerns which API Gateway Handles -

    1. Routing to Microservices -

      *   spring.cloud.gateway.server.webflux.routes[0].id=test
          spring.cloud.gateway.server.webflux.routes[0].uri=https://httpbin.org
          spring.cloud.gateway.server.webflux.routes[0].predicates[0]=Path=/test/**
      
          spring.cloud.gateway.server.webflux.routes[0].filters[0]=StripPrefix=1

    2. Handling Authentication and Jwt Validation -

      * Using security config we define rules to allow/disallow request and extract jwt tokens

      * @Configuration
        @EnableWebFluxSecurity
        public class SecurityConfig {
          @Bean
          SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
            return http.csrf(ServerHttpSecurity.CsrfSpec::disable)
                .authorizeExchange(exchange -> exchange
                    .pathMatchers("/api/v1/users/status", "/api/v1/users/register", "/api/v1/users/login")
                    .permitAll().anyExchange().authenticated())
                .oauth2ResourceServer(oauth2 -> oauth2.jwt())
                .build();
          }
        }
      
    3. Headers transformation -

      * Removing Authorization Bearer token i.e jwt and sending custom header so that Microservices
        knows that the request is from Gateway server
      
      * .header("X-User-Id", userId)
        .header("X-Gateway-Auth", "pixxy-gateway").headers(h -> h.remove("Authorization")).build();
    
    4. Rate Limiting -

      Rate limiting runs before authentication
      RequestRateLimiter executes before JWT validation
      Redis is required to implement Rate Limiting

      * package - spring-boot-starter-data-redis-reactive

    5. Logging -

    6. Global Error Handling -

    7. Circuit Breaker and Resilience -

    8. Transforming Request/Response -

    9. Observability (metrics & tracing) -

6. Design Patterns -