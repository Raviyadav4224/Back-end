1. What are Micro-Services -

    * Microservices are a way of designing an application as a collection of small, independent services 
      that each handle one specific task or feature

    * These services work together to build the complete system, but each one can be developed, deployed, 
      and maintained separately.

    * This makes the system easier to manage, scale, and update without affecting the entire application.

2. How it is implemented using Springboot -

    1. You set up Eureka Server, which acts as the discovery server.

    2. Each microservice acts as a Eureka Client, registers itself with Eureka Server at startup.

    3. When one microservice wants to communicate with another, it uses Feign Client.

        Feign automatically looks up the service from Eureka using the name specified.

        It builds the request to the correct instance without you needing to specify its IP or port.

3. Key Components of Microservices - 

    1. Service Discovery - Helps Microservices to find each other ( example using Eureka Server )
    2. API Gateway - Entry point for all Client Requests ( example Spring Cloud Gateway )
    3. Configuration Server - Central point to manage all Configuration ( example Spring Cloud config)
    4. Inter Service Communication - Services talk using RestTemplate  ( example using Feign Client )
    5. Load Balancing - Evenly distributes the Requests
    6. Resillence - Circuit Breakers, retires and timeout
    8. Security - JWTs and centralized authentication
    7. Monitoring - Health Check using Actuator  
    9. Logging - centralized log management

4. Interaction between one microservice and another microservice -

    | Type         | Example                    | Description                                             |
    | ------------ | -------------------------- | ------------------------------------------------------- |
    | Synchronous  | Feign Client, RestTemplate | Real-time communication; waits for a response.          |
    | Asynchronous | Kafka, RabbitMQ            | Decoupled communication; doesn’t wait. Used for events. |

    * Communication using RestTemplate -

        private RestTemplate restTemp= new RestTemplate();
        restTemp.getForObject("http://localhost:8082/inventory?id=" + id, String.class)
        
5. API Gateway -

    * API Gateway acts as a single entry point for all client requests in a microservices architecture.
      Handles routing, authentication, rate limiting, logging, and load balancing.

    * In Spring ecosystem, we use Spring Cloud Gateway 

    * Spring Cloud Gateway comes in two flavors based on the underlying web stack:

      Reactive Gateway (WebFlux-based)
      Non-Reactive Gateway (WebMVC / Servlet-based)
    
    * Reactive vs Non-Reactive Gateway -
      
      | Feature              | **Reactive Gateway (WebFlux)**       | **Non-Reactive Gateway (WebMVC / Servlet)** |
      | -------------------- | ------------------------------------ | ------------------------------------------- |
      | Underlying stack     | Spring **WebFlux**                   | Spring **WebMVC**                           |
      | Programming model    | Reactive (Mono / Flux)               | Imperative / Blocking                       |
      | I/O model            | **Non-blocking**                     | **Blocking**                                |
      | Web server           | **Netty** (event-loop based)         | **Tomcat / Jetty / Undertow**               |
      | Thread model         | Few threads handle many requests     | One thread per request                      |
      | Concurrency handling | Very high (thousands of connections) | Limited by thread pool                      |
      | Resource usage       | Low memory, efficient CPU            | Higher memory under load                    |
      | Gateway filters      | `GlobalFilter` (Reactive)            | Servlet filters (`OncePerRequestFilter`)    |
      | Security filters     | Reactive Security filters            | Servlet Security filters                    |
      | Best suited for      | API Gateway, edge layer, streaming   | Simple / internal gateways                  |
      | Typical traffic      | High throughput, I/O heavy           | Moderate traffic                            |
      | Common architecture  | Gateway = Reactive, Services = MVC   | Entire stack MVC                            |
      | Example use case     | Netflix-style edge gateway           | Internal company gateway                    |

    * Nginx vs Spring Cloud Gateway -
      
      Nginx is an Infrastructure aware gateway and optimized for traffic control and protection 
      It acts as a Load balancer and reverse Proxy

      Whereas Spring cloud gateway is an application/service aware gateway best at handling application 
      level logics

    * To Create Reactive Spring Cloud Gateway -

      * packages required - Reactive spring cloud gateway, spring security(For handling security), Oauth2-resolver
        (for handling JWT's)
    
6. Major concerns which API Gateway Handles -

    1. Routing to Microservices -

      * spring.cloud.gateway.server.webflux.routes[0].id=test
        spring.cloud.gateway.server.webflux.routes[0].uri=https://httpbin.org
        spring.cloud.gateway.server.webflux.routes[0].predicates[0]=Path=/test/**
      
        spring.cloud.gateway.server.webflux.routes[0].filters[0]=StripPrefix=1

    2. Handling Authentication and Jwt Validation -

      * Using security config we define rules to allow/disallow request and extract jwt tokens

      * @Configuration
        @EnableWebFluxSecurity
        public class SecurityConfig {
          @Bean
          SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
            return http.csrf(ServerHttpSecurity.CsrfSpec::disable)
                .authorizeExchange(exchange -> exchange
                    .pathMatchers("/api/v1/users/status", "/api/v1/users/register", "/api/v1/users/login")
                    .permitAll().anyExchange().authenticated())
                .oauth2ResourceServer(oauth2 -> oauth2.jwt())
                .build();
          }
        }
      
    3. Headers transformation -

      * Removing Authorization Bearer token i.e jwt and sending custom header so that Microservices
        knows that the request is from Gateway server
      
      * .header("X-User-Id", userId)
        .header("X-Gateway-Auth", "pixxy-gateway").headers(h -> h.remove("Authorization")).build();
    
    4. Rate Limiting -

      * Redis is required to implement Rate Limiting

      * package - spring-boot-starter-data-redis-reactive

      * Spring Cloud Gateway uses Redis + Lua scripts.

        Token Bucket Algorithm
        replenishRate → tokens added per second
        burstCapacity → max tokens
        requestedTokens → tokens per request

      * Why Redis is required

        In-memory rate limiting won’t scale
        Multiple Gateway instances need shared state

      * How Request Flows from Client -

        ┌──────────────────────────┐
        │        Client            │
        │  (Postman / Browser)     │
        └─────────────┬────────────┘
                      │
                      │  HTTP Request
                      │  Authorization: Bearer <JWT>
                      ▼
        ┌──────────────────────────┐
        │   Reactor Netty Server   │
        │  (HTTP entry point)      │
        └─────────────┬────────────┘
                      │
                      ▼
        ┌──────────────────────────────────────────┐
        │  Spring Security WebFilterChain          │
        │  (@EnableWebFluxSecurity)                │
        │                                          │
        │  - BearerTokenAuthenticationFilter       │
        │  - JwtAuthenticationProvider             │
        │  - Signature verification                │
        │  - Expiry check                          │
        │  - Claims decoding                       │
        │  - JwtAuthenticationToken created        │
        │  - Stored in ReactiveSecurityContext     │
        └─────────────┬────────────────────────────┘
                      │
                      │  (exchange.getPrincipal() ✔)
                      ▼
        ┌──────────────────────────────────────────┐
        │  Spring Cloud Gateway                    │
        │  FilteringWebHandler                     │
        │                                          │
        │  ┌────────────────────────────────────┐  │
        │  │   Gateway GlobalFilters            │  │
        │  │                                    │  │
        │  │ - RemoveCachedBodyFilter           │  │
        │  │ - ForwardPathFilter                │  │
        │  │ - JwtUserContextFilter (custom)    │  │
        │  │ - Logging / Auditing filters       │  │
        │  └────────────────────────────────────┘  │
        └─────────────┬────────────────────────────┘
                      │
                      ▼
        ┌──────────────────────────────────────────┐
        │  Route-Specific Filters                  │
        │                                          │
        │  - StripPrefix                           │
        │  - RequestRateLimiter (Redis)            │
        │    • KeyResolver                         │
        │    • Redis Lua script                    │
        │    • 429 if limit exceeded               │
        └─────────────┬────────────────────────────┘
                      │
                      ▼
        ┌──────────────────────────────────────────┐
        │  Routing Filters                         │
        │                                          │
        │  - NettyRoutingFilter                    │
        │  - WebSocketRoutingFilter                │
        │                                          │
        │  → Forwards request to downstream        │
        └─────────────┬────────────────────────────┘
                      │
                      ▼
        ┌──────────────────────────┐
        │   Microservice           │
        │   (file-service, etc.)   │
        └─────────────┬────────────┘
                      │
                      │  HTTP Response
                      ▼
        ┌──────────────────────────────────────────┐
        │  Response flows BACK (reverse order)     │
        │                                          │
        │  - Routing Filters                       │
        │  - Route Filters                         │
        │  - GlobalFilters                         │
        │  - Security context cleanup              │
        └─────────────┬────────────────────────────┘
                      │
                      ▼
        ┌──────────────────────────┐
        │        Client            │
        │     (HTTP Response)      │
        └──────────────────────────┘

      * Example -

        @Configuration
        public class RateLimiterConfig {
          @Bean
          KeyResolver userKeyResolver() {

            return exchange -> {

              System.out.println("Inside keyResolver"+exchange.getPrincipal());
              return exchange.getPrincipal().cast(JwtAuthenticationToken.class)
                  .map(jwt -> jwt.getToken().getClaimAsString("userId")).defaultIfEmpty("anonymous");
            };
          }

          @Bean
          RedisRateLimiter redisRateLimiter() {
          //		return new RedisRateLimiter(1, 2, 1);
            return new RedisRateLimiter(100, 200, 1);
          }
        }

        spring.cloud.gateway.server.webflux.routes[0].id=user-service
        spring.cloud.gateway.server.webflux.routes[0].uri=http://localhost:8081
        spring.cloud.gateway.server.webflux.routes[0].predicates[0]=Path=/api/v1/users/**
        spring.cloud.gateway.server.webflux.routes[0].filters[0]=StripPrefix=1

        ****** This is added as filter so that rate limiter can act ****** 
        spring.cloud.gateway.server.webflux.routes[0].filters[1]=RequestRateLimiter

        spring.cloud.gateway.server.webflux.routes[1].id=file-service
        spring.cloud.gateway.server.webflux.routes[1].uri=http://localhost:8082
        spring.cloud.gateway.server.webflux.routes[1].predicates[0]=Path=/api/v1/files/**
        spring.cloud.gateway.server.webflux.routes[1].filters[0]=StripPrefix=1
        spring.cloud.gateway.server.webflux.routes[1].filters[1]=RequestRateLimiter
        
    5. Centralized Logging -

      * Centralized logging in a microservices architecture is achieved by correlating logs belonging 
        to the same request across multiple services. This is primarily solved using a trace ID, which
        uniquely identifies a single request as it travels through the system.
      
      * When a client sends a request (for example, register or getFiles):
        The API Gateway creates a new trace.
        A trace ID (and initial span) is generated.
        This trace information is propagated downstream via HTTP headers.
        All downstream microservices reuse the same trace ID, allowing the entire request flow to be correlated.
        This is what makes centralized logging meaningful

      * In modern Spring Boot applications, Micrometer Tracing + OpenTelemetry is the production-grade solution.
        
        * Micrometer Tracing -

            Integrates directly with Spring Boot.
            Automatically:
            Creates trace IDs and span IDs.
            Propagates them across services.
            Attaches them to logs (traceId, spanId).

        * OpenTelemetry -

            Acts as the standard observability layer.
            Responsible for:
            Exporting traces (and optionally logs/metrics).
            Sending data to backends like Jaeger, Tempo, Zipkin, etc.
            Each microservice:
            Has its own logging configuration (logback-spring.xml).
            Writes logs locally (console or file).
            Includes traceId and spanId in every request-level log.

      * Reactive vs Non-Reactive API Gateway -

        * Reactive Gateway (Spring WebFlux) -

            Uses a non-blocking, multi-threaded execution model.
            MDC (ThreadLocal) is not reliable.
            Production approach:
            Use Micrometer Tracing + OpenTelemetry.
            Trace context is stored in the Reactor Context.
            Logging frameworks read trace information safely from this context.
            This is the recommended and production-grade approach for WebFlux.

        * Non-Reactive Gateway (Spring Web MVC) -
            
            Uses a thread-per-request model.
            MDC (Mapped Diagnostic Context) works reliably.
            Trace ID can be:
            Generated in a filter.
            Stored in MDC.
            Automatically added to all logs on that thread.
            This approach is simpler but only safe in Servlet-based applications.

      * Required Dependencies and Properties -

        * For Tracing  - micrometer-tracing-bridge-otel
          For Exporting  - opentelemetry-exporter-otlp
          Required  - spring-boot-starter-actuator

        * spring.application.name=file-service
          management.tracing.enabled=true
          management.tracing.sampling.probability=1.0
          management.endpoints.web.exposure.include=health,info

      * Log File Pattern -

          logging.level.com.pixxy.gateway=DEBUG
          logging.file.name=logs/${spring.application.name}.log
          logging.logback.rollingpolicy.file-name-pattern=logs/${spring.application.name}-%d{yyyy-MM-dd}.%i.log
          logging.logback.rollingpolicy.max-file-size=10MB
          logging.logback.rollingpolicy.max-history=30
          logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level traceId=%X{traceId} spanId=%X{spanId} %logger{36} - %msg%n
          logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level traceId=%X{traceId} spanId=%X{spanId} %logger{36} - %msg%n

      * Architecture Patterns for Logging -

        * Micrometer tracing is used to add traceId and spanId, opentelemetry is used to export traces to
          backend services like Tempo etc

        * Loki + Tempo + Promtail + Grafana 

          Loki - Stores Logs 
          Promtail - Reads logs and sends to Loki
          Tempo - Stores traces via OpenTelemetry
          Grafana - Visualization tool to analyse logs

        * AWS CloudWatch -

            It is used to store logs and can be visualized using Grafana

        * Elastic Search + Logback + Kibana -

          Elastic Search - Stores logs as JSON documents and provides full text search
          Logback - Collects and parses logs and converts the logs into JSON format 
          Kibana - Visualization tool to analyse logs

    6. Global Error Handling -

      * In a microservices architecture error handling works differently -
          API Gateway handles - security, routing, and infrastructure errors
          Microservices - handles business and domain errors
          Error response format - a common format is use which is mandatory across all layers

      * Global Error Response Object - 

        It includes typical fields such as 
          timestamp
          traceId
          path
          status
          message
          errors (optional / list)

      * Reactive Gateway -

        * For security related errors -

          We implement ServerAuthenticationEntryPoint(401), ServerAccessDeniedHandler(403) class
          example -
            public class GatewayAccessDeniedError implements ServerAccessDeniedHandler {

              private final ObjectMapper mapper;

              public GatewayAccessDeniedError(ObjectMapper mapper) {
                this.mapper = mapper;
              }

              @Override
              public Mono<Void> handle(ServerWebExchange exchange, AccessDeniedException ex) {
                ServerHttpResponse response = exchange.getResponse();
                response.setStatusCode(HttpStatus.FORBIDDEN);
                response.getHeaders().setContentType(MediaType.APPLICATION_JSON);

                GlobalErrorResponse body = new GlobalErrorResponse(Instant.now(), HttpStatus.FORBIDDEN.value(), "Access denied",
                    ex.getMessage(), exchange.getRequest().getPath().value(),
                    exchange.getRequest().getHeaders().getFirst("traceparent"));

                byte[] bytes;
                try {
                  bytes = mapper.writeValueAsBytes(body);
                } catch (Exception e) {
                  bytes = new byte[0];
                }

                DataBuffer buffer = response.bufferFactory().wrap(bytes);
                return response.writeWith(Mono.just(buffer));
              }
              }
        
        * For Global Error -

          We implement ErrorWebExceptionHandler class
          example -
            public class GatewayGlobalErrorHandler implements ErrorWebExceptionHandler {
              private final ObjectMapper mapper;
              private final Tracer tracer;

              public GatewayGlobalErrorHandler(Tracer tracer, ObjectMapper mapper) {
                this.mapper = mapper;
                this.tracer = tracer;
              }

              @Override
              public Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {

                ServerHttpResponse response = exchange.getResponse();
                HttpStatus status = getResponseStatus(ex);

                response.setStatusCode(status);

                response.getHeaders().setContentType(MediaType.APPLICATION_JSON);

                GlobalErrorResponse errorResponse = new GlobalErrorResponse(Instant.now(), status.value(),
                    status.getReasonPhrase(), resolveMessage(ex), exchange.getRequest().getPath().value(), getTraceId());

                byte[] body;
                try {
                  body = mapper.writeValueAsBytes(errorResponse);
                } catch (Exception e) {
                  body = new byte[0];
                }

                DataBuffer buffer = response.bufferFactory().wrap(body);
                return response.writeWith(Mono.just(buffer));
              }

              public HttpStatus getResponseStatus(Throwable ex) {
                if (ex instanceof ResponseStatusException rse) {
                  return HttpStatus.valueOf(rse.getStatusCode().toString());
                }

                if (ex instanceof TimeoutException) {
                  return HttpStatus.GATEWAY_TIMEOUT;
                }

                if (ex instanceof ConnectException || ex instanceof UnknownHostException) {
                  return HttpStatus.SERVICE_UNAVAILABLE;
                }

                return HttpStatus.INTERNAL_SERVER_ERROR;
              }

              private String resolveMessage(Throwable ex) {

                if (ex instanceof ResponseStatusException rse) {
                  return rse.getReason();
                }

                if (ex instanceof TimeoutException) {
                  return "Downstream service timed out";
                }

                if (ex instanceof ConnectException) {
                  return "Downstream service unavailable";
                }

                return "Unexpected gateway error";
              }

              private String getTraceId() {

                Span span = tracer.currentSpan();
                return span != null ? span.context().traceId() : UUID.randomUUID().toString();
              }
              }

      * TraceId - Generated via micrometer tracing , but if it is missing we generate it manually so that
        logs can be traced -  UUID.randomUUID().toString()
      
      * Gateway never forwards 401/403 to downstream services.
        Services never try to handle authentication or authorization errors.
      
      * Microservices Error Handling -

        * Services handle only business and domain errors
        * Implemented using @RestControllerAdvice + @ExceptionHandler
        * Services always return the same GlobalErrorResponse object
        * Services do NOT handle 401 / 403 / JWT-related errors

    7. Network Timeout, Retry Handling, Circuit Breaker and Bulkhead using Resilience4j -

      * Timeout -> Retry -> Circuit Breaker -> Feign Client -> Feign Exception Handler -> Controller Response

      * Feign answers - what do I return when it fails?
        Resilience answers - how do I stop failures from spreading?
        
      * It is implemented at API gateway level and at each Microservice level
      
      * Timeout (Network Errors) -

          Call File Service
          wait max 2 seconds
          if no response → FAIL FAST

        * Timeout errors are network errors
          connect timeout = connection not established in time
          read timeout = server did not send data in time although connection was made
          these are network-level timeouts and not EXECUTION level timeouts
          execution slow ≠ fail timeout
          Handled by Feign

        * To handle execution level timeouts we need to use Resilience4j-TimeLimiter

        * #TIMEOUT
          feign.client.config.default.connect-timeout=2000
          feign.client.config.default.read-timeout=3000

      * Resilience4j TimeLimiter -

        * It enforces Execution time logic, if request doesn’t completes in X time fail fast

        * It is NOT a network timeout.

        * What problem it solves
          Downstream service is slow
          Business logic takes too long
          Threads keep waiting → system degrades
          
        * Works only on async calls
          CompletableFuture
          CompletionStage
          Reactive (Mono, Flux)
          Does not interrupt threads
          Cancels the Future, not the method
        
        * resilience4j.timelimiter.instances.fileService.timeout-duration=3s
          resilience4j.timelimiter.instances.fileService.cancel-running-future=true

      * Resilience4j Circuit Breaker -

        * Used when dependent service is down
          Three states - OPEN , CLOSED, HALF OPEN
          It protects the caller not the callee (i.e it protects UserService if it is calling FileService)

        * Circuit Breaker prevents repeated calls to a failing service.

        * It counts outcomes and not reasons, means it counts success or failure 

        * resilience4j.circuitbreaker.instances.fileService.sliding-window-size=10
          resilience4j.circuitbreaker.instances.fileService.failure-rate-threshold=50
          resilience4j.circuitbreaker.instances.fileService.wait-duration-in-open-state=30s

          sliding-window-size = 10
          → Look at last 10 calls

          failure-rate-threshold = 50%
          → If ≥5 failures → open circuit

          wait-duration-in-open-state = 30s
          → Keep circuit open for 30 seconds

      * Resilience4j Retry -

        * Retry is for Transient failures and not Systemic failures

        * Retry must apply only on -
          * Specific exception
          * Must have Max Attempts
          * Must have backoff i.e nevery retry immediately 

        * If circuitbreaker is Open i.e Service is down - Retry is skipped

        * Retry decides what count as failures

        * Example - 

            @Retry(name = "fileService", fallbackMethod = "fallback")
            @CircuitBreaker(name = "fileService")
            @TimeLimiter(name = "fileService")
            public CompletableFuture<String> getStatusAsync(long ms) {
              return CompletableFuture.supplyAsync(() -> fileServiceClient.status(ms));
            }

            public CompletableFuture<String> fallback(Throwable ex) {
              System.out.println(ex.getMessage());
              return CompletableFuture.completedFuture("File Service is Down");
            }

        * # ---------- RETRY ----------
          resilience4j.retry.instances.fileService.max-attempts=3
          
          resilience4j.retry.instances.fileService.wait-duration=1s

          resilience4j.retry.instances.fileService.enable-exponential-backoff=true

          resilience4j.retry.instances.fileService.exponential-backoff-multiplier=2

          resilience4j.retry.instances.fileService.retry-exceptions=\
          java.io.IOException,\
          java.net.SocketTimeoutException,\
          java.util.concurrent.TimeoutException

          resilience4j.retry.instances.fileService.ignore-exceptions=\
          io.github.resilience4j.circuitbreaker.CallNotPermittedException,\
          org.springframework.web.client.HttpClientErrorException

        * Retry
          └── CircuitBreaker
                └── TimeLimiter
                    └── Actual call
          The first fallback that executes absorbs the exception and stops the chain.

      * Resilience4j Bulkhead - 

        * CircuitBreaker protects the Downstream service whereas Bulkhead protects the calling service

        * It limits 

          * The no. of concurrent calls
          * When limit is hit - bulkheadFullException is thrown and it rejects immediately 
          * No waiting
          * No Retry(unless we specify it)

        * Types of BulkHead -

          1. Semaphore Bulkhead
          2. Threadpool Bulkhead

          | Aspect                         | **Semaphore Bulkhead**    | **ThreadPool Bulkhead**        |
          | ------------------------------ | ------------------------- | ------------------------------ |
          | Bulkhead Type                  | Semaphore-based           | Thread-pool-based              |
          | What it limits                 | **Concurrent executions** | **Threads + queue size**       |
          | Isolation level                | Medium                    | **Strong**                     |
          | Works with sync code           | ✅ Yes                    | ❌ No                         |
          | Works with `CompletableFuture` | ✅ Yes                    | ✅ Yes (required)             |
          | Thread usage                   | Uses **caller thread**    | Uses **separate thread pool**  |
          | Queue support                  | ❌ No queue              | ✅ Yes (bounded)               |
          | When limit is hit              | Immediate rejection       | Queue → then rejection         |
          | Failure exception              | `BulkheadFullException`   | `BulkheadFullException`        |
          | Latency behaviour              | Predictable               | Can increase due to queue      |
          | Risk of thread exhaustion      | Low                       | Very low                       |
          | Typical max size               | 5–50 concurrent calls     | Small pools (5–20 threads)     |
          | Best for                       | REST, Feign, DB calls     | Slow / blocking legacy systems |
          | Production usage               | **Most common**           | Selective / advanced           |

        * Example -

          	@Retry(name = "fileService", fallbackMethod = "fallbackRetry")
            @CircuitBreaker(name = "fileService")
            @TimeLimiter(name = "fileService")
            @Bulkhead(type = Type.SEMAPHORE, name = "fileService")
            public CompletableFuture<String> getStatusAsync(long ms) {
              ExecutorService executor = Executors.newFixedThreadPool(20);
              return CompletableFuture.supplyAsync(() -> fileServiceClient.status(ms), executor);
            }

            # ---------- BULKHEAD ----------
            resilience4j.bulkhead.instances.fileService.max-concurrent-calls=10
            resilience4j.bulkhead.instances.fileService.max-wait-duration=0

            Allows max 10 concurrent calls at once else throws error and goes to fallback method

    8. Transforming Request/Response -

      * In microservices, the API Gateway owns the external API contract. Even if backend services return
        raw or inconsistent responses, the gateway transforms them into a standard JSON structure using 
        response filters, ensuring consistency, loose coupling, and backward compatibility.
      
      * It is done at API Gateway level ensuring response consistency, and it is typically implemented
        at the route level because global transformation quickly becomes complex and difficult to manage.

    9. Observability (metrics & tracing) -
    
    10. Database/Transactions Handling in Microservices -

      * In microservices, database transactions are handled using SAGA patterns — 
        either orchestration or event-driven choreography — where each service commits locally and
        failures are handled via compensation, ensuring eventual consistency instead of distributed
        ACID transactions.

        example -

          User Service (create user) → File Service
                  ↓ failure
          Compensation (delete / revert user)

    11. Caching -

    12. Testing -

    13. Configuration Management & Discovery Server ( Kubernetes ) -

      * Configuration management in microservices is handled either via Kubernetes ConfigMaps and Secrets
        during deployment, or through Spring Cloud Config for centralized, Git-backed configuration—chosen
        based on whether the system is containerized or not.

      * For most of the systems which are now containerized Kubernetes based approach is used

      * In Kubernetes-based microservices, service discovery is handled natively using Services and DNS,
        making tools like Eureka unnecessary.

7. Design Patterns -
