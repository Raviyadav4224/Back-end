1. Kubernetes - 

    * It is a container orchestration tool used for managing, scaling and deploying containerized based
      applications.

2. Pods -

    * It is the smallest deployable unit

    * Runs one container ( say one microservice )

    * It is Ephemeral i.e its IP changes on restart

3. Deployment -

    * Manages the pods, Ensures desired no of replicas, handles Scaling, restart on Crash, rolling
      upates etc

4. Service -

    * It sits infront of Deployment i.e One service per deployment

    * It is used to provide stable network endpoint infront of pods

    * It provides DNS name, Load balancing and decouples client from PODs ip's

    * Service Types -

        * ClusterIp (default) -

            Used for internal service communication
        
        * NodePort -

            Exposes service on <NodeIP>:port
        
        * Load balancer -

            Creates cloud load balancer and Works in cloud only (AWS, GCP etc)
        
        * ExternalName -

            Maps services to external DNS

5. Ingress -

    * Entry point into the Cluster

    * Routes HTTP/HTTPS traffics

    * Talks to services and not pods

    * Handles path/host based routing

6. Networking -

7. Service Discovery -

    * Kubernetes provides built in service discovery using Service and DNS

    * It replaces the need of Eureka Server 

8. Config Maps & Secrets -

    * These are used to store Application configs and secrets and are injected as environment variables
    
    * Secret.yaml file is encrypted wheareas configmap.yaml is not encrypted
    
9. Kubernetes deployment steps -

    * We first create NAMESPACE = Folder inside Kubernetes Cluster

    * To deploy an application using Kubernetes we create four files -

        1. deployment.yaml 

            Runs your Docker image as Pods (your application)
            
        2. service.yaml

            Gives network access inside cluster (DNS name)
           
        3. configmap.yaml

            Stores normal environment variables

        4. secret.yaml

            Stores sensitive values (passwords, JWT keys, etc.)

10. Basic Commands -

    * To apply any deployment, service, configmap or secrets    

        kubectl apply -f filepath

        Examples -
        
            kubectl apply -f user-service.yaml
            kubectl apply -f user-deployment.yaml
            kubectl apply -f configmap.yaml
            kubectl apply -f user-secret.yaml

    * Namespace -

        kubectl get ns
        kubectl create ns my-namespace
    
    * Deployments -

        kubectl get deployments
        kubectl describe deployments deploymentName
        kubectl scale deployment user-service --replicas=3
        kubectl delete deployment user-service
    
    * Pods -

        kubectl get pods
        kubectl get pods -o wide
        kubectl describe pod <pod-name>
        kubectl logs <pod-name>
        kubectl logs -f <pod-name>
        kubectl exec -it <pod-name> -- bash

    * Services -

        kubectl get svc
        kubectl describe svc user-service
        kubectl delete svc user-service
    
    * Ingress -
    
        kubectl get ingress
        kubectl describe ingress user-ingress
    
    * Delete everything -

        * kubectl delete all --all -n pixxy - Deletes services, deployment and pods but NOT configmap & secrets

        * kubectl delete secret/configmap --all -n pixxy - Deletes configmap/secret

        * kubectl delete ns pixxy - deletes entire namespace

    * General request flow -

        * When NOT using ingress -> Browser ( Client ) â†’ localhost:30080 â†’ Service â†’ Pods

        * When using ingress -> Browser ( Client ) â†’ Ingress Controller â†’ Service â†’ Pods

        * For ingress we need to add route mapping in host file 
          In windows - C:\Windows\System32\drivers\etc\hosts.ics
          In Linux - /etc/hosts

    * Get inside POD -

        kubectl get pods

        kubectl exec -it <pod-name> -- bin/bash or -- /bin/sh

11. Kubernetes Cluster -

    * A cluster = the whole Kubernetes system.
        It contains:

    * Control Plane (inside the cluster)

        Responsible for:
        Accepting kubectl commands
        Scheduling pods
        Managing desired state
        Health checks
        It does NOT run your application containers.

    * Worker Nodes (inside the same cluster)

        Responsible for:
        Running Pods
        Running your containers (user-service, Kafka, MySQL, etc)
        This is where actual work happens.
        ðŸ‘‰ Control Plane (brain)
        ðŸ‘‰ Worker Nodes (machines that run apps)

        Itâ€™s ONE logical unit.
